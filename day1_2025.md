# Advent of Code 2025 - Day 1: Safe Cracking

## Problem Summary

The puzzle involves simulating a circular dial with numbers 0-99. Given a sequence of rotation instructions, we need to track the dial's position and count how many times it points to 0 after any rotation.

### Problem Details

- **Starting Position**: The dial starts at 50
- **Dial Range**: 0 to 99 (circular, wraps around)
- **Rotation Instructions**:
  - `L<distance>`: Rotate left (toward lower numbers) by `<distance>` clicks
  - `R<distance>`: Rotate right (toward higher numbers) by `<distance>` clicks
- **Goal**: Count how many times the dial points at 0 after completing each rotation

### Example

Given the rotations:
```
L68, L30, R48, L5, R60, L55, L1, L99, R14, L82
```

The dial moves:
```
Start: 50
L68: 50 - 68 = -18 ≡ 82 (mod 100)
L30: 82 - 30 = 52
R48: 52 + 48 = 100 ≡ 0 (mod 100) ← Zero!
L5: 0 - 5 = -5 ≡ 95 (mod 100)
R60: 95 + 60 = 155 ≡ 55 (mod 100)
L55: 55 - 55 = 0 ← Zero!
L1: 0 - 1 = -1 ≡ 99 (mod 100)
L99: 99 - 99 = 0 ← Zero!
R14: 0 + 14 = 14
L82: 14 - 82 = -68 ≡ 32 (mod 100)
```

The dial points at 0 three times, so the password is **3**.

## Solution Approach

### Algorithm: Modular Arithmetic Simulation

**Part 1 Strategy:**
- Simulate dial rotations with modular arithmetic
- Track position after each rotation
- Count when position equals 0

**Part 2 Strategy:**
- Calculate zero crossings mathematically (not simulation)
- Use formulas to count how many times 0 is passed during each rotation
- Handle edge case when starting position is 0

**Complexity:**
- Time: O(n) where n = number of rotations
- Space: O(1)

### Algorithm Details

The solution uses a straightforward simulation approach:

1. **Initialize**: Start with position = 50 and zero_count = 0
2. **Parse Each Rotation**: Extract direction (L/R) and distance
3. **Update Position**: Apply modular arithmetic for circular wrapping
   - Left rotation: `position = (position - distance) % 100`
   - Right rotation: `position = (position + distance) % 100`
4. **Check for Zero**: After each rotation, check if position == 0
5. **Count**: Increment zero_count if the dial points at 0

### Key Algorithmic Decisions

1. **Modular Arithmetic**: The use of Python's `%` operator elegantly handles:
   - Positive wrapping (e.g., 99 + 1 = 0)
   - Negative wrapping (e.g., 0 - 1 = 99)
   - Python's modulo operation always returns non-negative results for positive modulus

2. **Single Pass**: The problem requires only one iteration through the rotation list, making it O(n) time complexity where n is the number of rotations

3. **Space Efficiency**: The solution uses O(1) extra space, only tracking current position and count

### Complexity Analysis

- **Time Complexity**: O(n) where n is the number of rotation instructions
- **Space Complexity**: O(1) - only a few variables are used regardless of input size
- **Input Parsing**: O(n) to read and parse the rotation instructions

### Python Features Used

1. **String Slicing**: `rotation[0]` for direction, `rotation[1:]` for distance
2. **Modular Arithmetic**: `%` operator for circular wrapping
3. **Type Hints**: Modern Python type annotations for clarity (`list[str]`, `int`)
4. **aocd Package**: Automated puzzle input retrieval using `Puzzle` class

## Implementation Details

### Dependencies

- **aocd**: For fetching puzzle input automatically
  - Install: `pip install advent-of-code-data`
  - Requires AOC session token configuration

### Code Structure

```python
def solve_part1(rotations: list[str]) -> int:
    """Count times dial lands on 0 after rotations"""
    # Simulate dial rotations
    # Count zeros at end of each rotation
    # Return count

def solve_part2(rotations: list[str]) -> int:
    """Count all times dial points at 0 during rotations"""
    # Calculate zero crossings for each rotation
    # Handle edge cases (starting at 0)
    # Return total count

def test_example():
    """Validation with provided examples"""
    # Test Part 1 and Part 2
    # Verify logic matches expected output

def main():
    """Orchestrate puzzle solving"""
    # Fetch input
    # Solve both parts
    # Submit answers
```

### Edge Cases Handled

**Part 1:**
1. **Negative Values**: Python's modulo handles negative intermediate values correctly
   - Example: `(0 - 5) % 100 = 95`
2. **Large Rotations**: Distances larger than 100 are handled by modulo
   - Example: `(50 + 150) % 100 = 0`
3. **Landing on Zero**: If rotation ends on 0, it's correctly counted

**Part 2:**
1. **Starting at Zero**: Critical edge case - when position is 0, first click moves away
   - R1 from 0 → 1 (not counting the starting 0)
   - L1 from 0 → 99 (not counting the starting 0)
2. **Multiple Crossings**: Large rotations can cross 0 multiple times
   - R1000 from 50 crosses 0 ten times: at positions 100, 200, ..., 1000
3. **No Crossings**: Short rotations that don't reach 0
   - L5 from 10 → 5 (never crosses 0)

## Testing

The solution includes a comprehensive test using the provided example:

```python
def test_example():
    example_rotations = ["L68", "L30", "R48", "L5", "R60", "L55", "L1", "L99", "R14", "L82"]
    result = solve_part1(example_rotations)
    assert result == 3
```

### Verification Output

```
Example trace:
Start: 50
L68: 82
L30: 52
R48: 0 <- Zero!
L5: 95
R60: 55
L55: 0 <- Zero!
L1: 99
L99: 0 <- Zero!
R14: 14
L82: 32

Zero count: 3
Example test passed!
```

## Part 2: Counting All Zero Crossings

### Enhanced Problem

Part 2 introduces "password method 0x434C49434B" which requires counting **every time** the dial points at 0, including:
- Landing on 0 at the end of a rotation
- Passing through 0 **during** a rotation

This is significantly different from Part 1, which only counted final positions.

### Part 2 Algorithm

The key insight is calculating how many times we pass through 0 during a rotation:

**For Right Rotations (R):**
- Starting from position `p`, rotating right by `d` clicks
- We hit 0 at positions: 100, 200, 300, etc. (in absolute terms)
- Formula: `count = floor((p + d) / 100) - floor(p / 100)`
- Special case: If `p == 0`, the first click takes us to 1, so `count = d // 100`

**For Left Rotations (L):**
- Starting from position `p`, rotating left by `d` clicks
- Going left means: p, p-1, p-2, ..., 1, 0, 99, 98, ...
- We hit 0 after `p` clicks, then every 100 clicks thereafter
- Formula:
  - If `p == 0`: `count = d // 100` (first click goes to 99)
  - If `d >= p`: `count = floor((d - p) / 100) + 1`
  - If `d < p`: `count = 0` (never reach 0)

### Critical Edge Case

When the dial is **already at position 0**, the first click moves us away from 0:
- R1 from 0 goes to 1 (not counting the starting 0)
- L1 from 0 goes to 99 (not counting the starting 0)

This is crucial: we count each time a **click causes** the dial to point at 0, not the starting position.

### Example Analysis

Using the same example rotations:

```
Start: 50
L68: 50 -> 82  | Passes through 0 once (50→49→...→1→0→99→...→82)
L30: 82 -> 52  | No zeros (82→81→...→52)
R48: 52 -> 0   | Lands on 0 (52→53→...→99→0)
L5:  0 -> 95   | No zeros (starting at 0, goes to 99→98→...→95)
R60: 95 -> 55  | Passes through 0 once (95→96→...→99→0→1→...→55)
L55: 55 -> 0   | Lands on 0 (55→54→...→1→0)
L1:  0 -> 99   | No zeros (starting at 0, goes to 99)
L99: 99 -> 0   | Lands on 0 (99→98→...→1→0)
R14: 0 -> 14   | No zeros (starting at 0, goes to 1→2→...→14)
L82: 14 -> 32  | Passes through 0 once (14→13→...→1→0→99→...→32)
```

Total: 6 times the dial points at 0

### Part 2 Implementation

```python
def solve_part2(rotations: list[str]) -> int:
    position = 50
    zero_count = 0

    for rotation in rotations:
        direction = rotation[0]
        distance = int(rotation[1:])

        if direction == 'R':
            if position == 0:
                zeros_crossed = distance // 100
            else:
                zeros_crossed = (position + distance) // 100 - position // 100
            position = (position + distance) % 100
        else:  # L
            if position == 0:
                zeros_crossed = distance // 100
            elif distance >= position:
                zeros_crossed = (distance - position) // 100 + 1
            else:
                zeros_crossed = 0
            position = (position - distance) % 100

        zero_count += zeros_crossed

    return zero_count
```

## Results

- **Part 1 Answer**: 1029
  - The dial points at 0 a total of **1029 times** after rotations
- **Part 2 Answer**: 5892
  - The dial points at 0 a total of **5892 times** including during rotations

## Running the Solution

```bash
# Ensure aocd is installed and configured
pip install advent-of-code-data

# Run the solution
python day1_2025.py
```

### Expected Output

```
=== Part 1 Test ===
Example trace:
Start: 50
L68: 82
L30: 52
R48: 0 <- Zero!
L5: 95
R60: 55
L55: 0 <- Zero!
L1: 99
L99: 0 <- Zero!
R14: 14
L82: 32

Part 1 - Zero count: 3
Part 1 test passed!

=== Part 2 Test ===
Start: 50
L68: 50 -> 82 (hits 0 1 time(s))
L30: 82 -> 52
R48: 52 -> 0 (hits 0 1 time(s))
L5: 0 -> 95
R60: 95 -> 55 (hits 0 1 time(s))
L55: 55 -> 0 (hits 0 1 time(s))
L1: 0 -> 99
L99: 99 -> 0 (hits 0 1 time(s))
R14: 0 -> 14
L82: 14 -> 32 (hits 0 1 time(s))

Part 2 - Total zero count: 6
Part 2 test passed!

==================================================

Part 1: The password is 1029
Part 2: The password is 5892
```

## Best Practices Demonstrated

1. **Code Readability**: Clear variable names and well-documented functions
2. **Modularity**: Separated concerns (parsing, solving, testing, main)
3. **Type Safety**: Modern Python type hints for better IDE support
4. **Testing**: Included example test for validation
5. **Documentation**: Comprehensive docstrings and comments
6. **Error Handling**: Implicit through Python's robust modulo operation

## References

- Modular arithmetic: Standard mathematical operation for circular data structures
- Python modulo operator: Always returns non-negative values for positive modulus
- aocd package: Simplifies Advent of Code input management

## Complexity Analysis - Part 2

- **Time Complexity**: O(n) where n is the number of rotation instructions
  - Each rotation is processed in constant time with mathematical formulas
  - No iteration through individual clicks needed
- **Space Complexity**: O(1) - only tracking position and count
- **Key Optimization**: Using mathematical formulas instead of simulating each click
  - Without optimization: O(n × d) where d is average rotation distance
  - With optimization: O(n) - massive improvement for large rotations

## Potential Optimizations

For this particular problem, the solution is already optimal:
- **No caching needed**: Each rotation is independent and processed once
- **No advanced data structures needed**: Simple integer arithmetic suffices
- **Mathematical formulas**: Used instead of simulation for O(1) per rotation
- **No algorithmic improvements**: Single-pass linear scan with constant-time operations

The key insight for Part 2 is recognizing that we can calculate zero crossings mathematically rather than simulating each individual click, which would be prohibitively slow for large rotation distances.
