# Day 1: Safe Cracking - Advent of Code 2025

## Problem Overview

The puzzle involves cracking a safe with a circular dial. Given a sequence of rotation instructions, we need to track when the dial points to position 0 - both after completing rotations (Part 1) and while passing through 0 during rotations (Part 2).

### Problem Details

**Part 1: Landing on Zero**
- Circular dial with numbers 0-99
- Starting position: 50
- Rotation instructions: `L<distance>` (left) or `R<distance>` (right)
- Count how many times the dial points at 0 **after** completing each rotation

**Part 2: Passing Through Zero**
- Same setup as Part 1
- Count **all times** the dial points at 0, including:
  - Landing on 0 at the end of a rotation
  - Passing through 0 **during** a rotation

### Example

Given the rotations:
```
L68, L30, R48, L5, R60, L55, L1, L99, R14, L82
```

**Part 1 Analysis:**

```
Start: 50
L68: 50 - 68 = -18 ≡ 82 (mod 100)
L30: 82 - 30 = 52
R48: 52 + 48 = 100 ≡ 0 (mod 100) ← Zero!
L5: 0 - 5 = -5 ≡ 95 (mod 100)
R60: 95 + 60 = 155 ≡ 55 (mod 100)
L55: 55 - 55 = 0 ← Zero!
L1: 0 - 1 = -1 ≡ 99 (mod 100)
L99: 99 - 99 = 0 ← Zero!
R14: 0 + 14 = 14
L82: 14 - 82 = -68 ≡ 32 (mod 100)
```

The dial lands on 0 **three times**, so the password is **3**.

**Part 2 Analysis:**

```
Start: 50
L68: 50 -> 82  | Passes through 0 once (50→49→...→1→0→99→...→82)
L30: 82 -> 52  | No zeros (82→81→...→52)
R48: 52 -> 0   | Lands on 0 (52→53→...→99→0)
L5:  0 -> 95   | No zeros (starting at 0, goes to 99→98→...→95)
R60: 95 -> 55  | Passes through 0 once (95→96→...→99→0→1→...→55)
L55: 55 -> 0   | Lands on 0 (55→54→...→1→0)
L1:  0 -> 99   | No zeros (starting at 0, goes to 99)
L99: 99 -> 0   | Lands on 0 (99→98→...→1→0)
R14: 0 -> 14   | No zeros (starting at 0, goes to 1→2→...→14)
L82: 14 -> 32  | Passes through 0 once (14→13→...→1→0→99→...→32)
```

Total: **6 times** the dial points at 0 (including during rotations)

---

## Solution Approach

### Algorithms

**Part 1 Strategy:** Modular arithmetic simulation
- Simulate dial rotations with modular arithmetic
- Track position after each rotation
- Count when position equals 0

**Part 2 Strategy:** Mathematical zero-crossing calculation
- Calculate zero crossings mathematically (not simulation)
- Use formulas to count how many times 0 is passed during each rotation
- Handle edge case when starting position is 0

**Complexity:**
- Part 1: O(n) where n = number of rotations
- Part 2: O(n) where n = number of rotations

### Algorithm Details

#### Part 1: Modular Arithmetic Simulation

```python
def solve_part1(rotations: list[str]) -> int:
    position = 50  # Starting position
    zero_count = 0

    for rotation in rotations:
        direction = rotation[0]
        distance = int(rotation[1:])

        if direction == 'L':
            # Left rotation: subtract and wrap with modulo
            position = (position - distance) % 100
        else:  # direction == 'R'
            # Right rotation: add and wrap with modulo
            position = (position + distance) % 100

        # Check if dial points at 0 after this rotation
        if position == 0:
            zero_count += 1

    return zero_count
```

#### Part 2: Mathematical Zero Crossing

```python
def solve_part2(rotations: list[str]) -> int:
    position = 50
    zero_count = 0

    for rotation in rotations:
        direction = rotation[0]
        distance = int(rotation[1:])

        if direction == 'R':
            # Right rotation: calculate zero crossings
            if position == 0:
                zeros_crossed = distance // 100
            else:
                zeros_crossed = (position + distance) // 100 - position // 100
            position = (position + distance) % 100

        else:  # direction == 'L'
            # Left rotation: calculate zero crossings
            if position == 0:
                zeros_crossed = distance // 100
            elif distance >= position:
                zeros_crossed = (distance - position) // 100 + 1
            else:
                zeros_crossed = 0
            position = (position - distance) % 100

        zero_count += zeros_crossed

    return zero_count
```

### Key Algorithmic Decisions

**1. Modular Arithmetic**

Python's `%` operator elegantly handles:
- Positive wrapping: `99 + 1 = 0`
- Negative wrapping: `0 - 1 = 99`
- Python's modulo always returns non-negative results for positive modulus

**2. Mathematical Zero Crossing Formulas**

**For Right Rotations (R):**
- Starting from position `p`, rotating right by `d` clicks
- We hit 0 at positions: 100, 200, 300, etc. (in absolute terms)
- Formula: `count = floor((p + d) / 100) - floor(p / 100)`
- Special case: If `p == 0`, first click takes us to 1, so `count = d // 100`

**For Left Rotations (L):**
- Starting from position `p`, rotating left by `d` clicks
- We hit 0 after `p` clicks, then every 100 clicks thereafter
- Formula:
  - If `p == 0`: `count = d // 100` (first click goes to 99)
  - If `d >= p`: `count = floor((d - p) / 100) + 1`
  - If `d < p`: `count = 0` (never reach 0)

**3. Critical Edge Case: Starting at Zero**

When the dial is **already at position 0**, the first click moves us away:
- R1 from 0 goes to 1 (not counting the starting 0)
- L1 from 0 goes to 99 (not counting the starting 0)

We count each time a **click causes** the dial to point at 0, not the starting position.

**4. Optimization: Math vs Simulation**

Part 2 uses mathematical formulas instead of simulating each click:
- Without optimization: O(n × d) where d = average rotation distance
- With optimization: O(n) - massive improvement for large rotations

### Complexity Analysis

**Part 1:**
- Parse rotations: O(n)
- Process each rotation: O(1) per rotation
- **Total:** O(n)

**Part 2:**
- Parse rotations: O(n)
- Calculate zero crossings: O(1) per rotation (mathematical formula)
- **Total:** O(n)

**Key optimization:** Using formulas instead of simulating individual clicks.

### Python Dependencies Used

```python
from aocd.models import Puzzle  # For AoC integration
```

**Built-in features:**
- String slicing: `rotation[0]` for direction, `rotation[1:]` for distance
- Modular arithmetic: `%` operator
- Type hints: `list[str]`, `int`

---

## Implementation Details

### Dependencies

```python
from aocd.models import Puzzle
```

**Installation:**
```bash
pip install advent-of-code-data
```

Requires AOC session token configuration.

### Code Structure

```
day1_2025.py
├── solve_part1(rotations)  # Simulation with modular arithmetic
├── solve_part2(rotations)  # Mathematical zero crossing
├── test_example()          # Comprehensive validation
└── main()                  # Puzzle orchestration
```

---

## Running the Solution

```bash
# Ensure aocd is installed and configured
pip install advent-of-code-data

# Run the solution
python day1_2025.py
```

**Expected Output:**

```
=== Part 1 Test ===
Example trace:
Start: 50
L68: 82
L30: 52
R48: 0 <- Zero!
L5: 95
R60: 55
L55: 0 <- Zero!
L1: 99
L99: 0 <- Zero!
R14: 14
L82: 32

Part 1 - Zero count: 3
Part 1 test passed!

=== Part 2 Test ===
Start: 50
L68: 50 -> 82 (hits 0 1 time(s))
L30: 82 -> 52
R48: 52 -> 0 (hits 0 1 time(s))
L5: 0 -> 95
R60: 95 -> 55 (hits 0 1 time(s))
L55: 55 -> 0 (hits 0 1 time(s))
L1: 0 -> 99
L99: 99 -> 0 (hits 0 1 time(s))
R14: 0 -> 14
L82: 14 -> 32 (hits 0 1 time(s))

Part 2 - Total zero count: 6
Part 2 test passed!

==================================================

Part 1: The password is 1029
Part 2: The password is 5892
```

---

## Best Practices Demonstrated

### 1. Edge Case Handling

**Part 1:**
- Negative values: Python's modulo handles correctly (`(0 - 5) % 100 = 95`)
- Large rotations: Modulo handles wrapping (`(50 + 150) % 100 = 0`)
- Landing on zero: Correctly counted

**Part 2:**
- Starting at zero: Critical edge case - first click moves away
- Multiple crossings: Large rotations crossing 0 multiple times
- No crossings: Short rotations that don't reach 0

### 2. Mathematical Optimization

Using formulas instead of simulation:
- Part 2 doesn't simulate each click
- Calculates crossings in O(1) per rotation
- Essential for large rotation distances

### 3. Comprehensive Testing

```python
def test_example():
    example_rotations = ["L68", "L30", "R48", "L5", "R60", "L55", "L1", "L99", "R14", "L82"]
    result1 = solve_part1(example_rotations)
    assert result1 == 3
    result2 = solve_part2(example_rotations)
    assert result2 == 6
```

### 4. Clear Code Organization

- Separated concerns: parsing, solving, testing, main
- Well-documented functions with docstrings
- Type hints for better IDE support
- Descriptive variable names

### 5. Single-Pass Efficiency

- Only one iteration through rotations needed
- O(1) space complexity
- No caching or memoization needed

---

## References

### Mathematical Concepts

- **Modular Arithmetic**: Standard operation for circular data structures
- **Python Modulo**: Always returns non-negative values for positive modulus
- **Zero Crossing Calculation**: Mathematical optimization for counting crossings

### Similar Problems

- Circular buffer problems
- Clock arithmetic
- Angle calculations with wrapping

### Further Reading

- [Modular Arithmetic (Wikipedia)](https://en.wikipedia.org/wiki/Modular_arithmetic)
- [Python Modulo Operator](https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations)
- [AOC Data Package](https://github.com/wimglenn/advent-of-code-data)

---

## Answers

- **Part 1**: 1,029 (dial lands on 0 after rotations)
- **Part 2**: 5,892 (dial points at 0 including during rotations)

---

## Conclusion

This problem demonstrates the power of **mathematical optimization** over brute-force simulation:

**Key Takeaways:**

1. **Modular arithmetic** elegantly handles circular data structures
2. **Mathematical formulas** can replace expensive simulations
3. **Edge cases** (starting at 0) require careful handling
4. **Single-pass algorithms** are sufficient for sequential processing

**Optimization Insight:**

The transition from Part 1 (simulation) to Part 2 (calculation) shows a crucial algorithmic improvement:
- Naive approach: Simulate every click → O(n × d) where d = rotation distance
- Optimized approach: Calculate crossings → O(n) regardless of distance

This 100x-1000x speedup demonstrates why understanding the mathematics behind a problem is essential for efficient solutions.
