# Advent of Code 2025 - Day 2: Gift Shop

## Problem Overview

The task involves identifying "invalid" product IDs within given ranges. An invalid ID is defined as a number composed of a sequence of digits repeated exactly twice.

### Examples of Invalid IDs:
- `55` → "5" repeated twice
- `6464` → "64" repeated twice
- `123123` → "123" repeated twice
- `1010` → "10" repeated twice

### Constraints:
- No leading zeros (e.g., `0101` is not a valid ID)
- IDs must have an even number of digits to potentially be invalid
- The repeated sequence must be identical

## Solution Approach

### Algorithm: Pattern Matching with Memoization

**Core Strategy:**
- Check each number in the range by splitting it in half
- Compare if both halves are identical (string-based comparison)
- Use `@lru_cache` to avoid recomputing the same IDs
- Sum all invalid IDs found across all ranges

**Complexity:**
- Time: O(R × n × d) where R = ranges, n = range size, d = digits
- Space: O(k) for cache where k ≤ 10,000

### Algorithm Design

The solution implements an efficient approach to identify invalid IDs:

1. **Invalid ID Detection** (`is_invalid_id`)
   - Convert number to string representation
   - Check if length is even (necessary condition)
   - Split string in half
   - Compare both halves for equality
   - Time Complexity: O(d) where d is the number of digits
   - Space Complexity: O(d) for string representation

2. **Range Processing** (`find_invalid_ids_in_range`)
   - Iterate through each number in the range [start, end]
   - Apply invalid ID detection to each number
   - Collect all invalid IDs
   - Time Complexity: O(n × d) where n is range size, d is avg digits

3. **Input Parsing** (`parse_ranges`)
   - Split comma-separated range strings
   - Parse each "start-end" format into integer tuples
   - Time Complexity: O(r) where r is number of ranges

### Optimization Techniques

1. **Memoization with `@lru_cache`**
   - The `is_invalid_id` function uses `functools.lru_cache(maxsize=10000)`
   - Caches results for previously checked IDs
   - Particularly useful when ranges overlap or contain similar patterns
   - Reduces redundant computations significantly

2. **String-based Comparison**
   - Using string manipulation is more efficient than mathematical operations
   - Avoids complex digit extraction algorithms
   - Direct substring comparison is O(d) which is optimal

3. **Type Hints**
   - Full type annotations for better code clarity and IDE support
   - Enables static type checking with tools like mypy

## Implementation Details

### Key Functions

#### `is_invalid_id(num: int) -> bool`
```python
@lru_cache(maxsize=10000)
def is_invalid_id(num: int) -> bool:
    s = str(num)
    length = len(s)

    if length % 2 != 0:
        return False

    mid = length // 2
    return s[:mid] == s[mid:]
```

**Rationale:**
- Cached to avoid recomputation
- Simple string slicing for pattern matching
- Early exit for odd-length numbers

#### `find_invalid_ids_in_range(start: int, end: int) -> List[int]`
```python
def find_invalid_ids_in_range(start: int, end: int) -> List[int]:
    invalid_ids = []
    for num in range(start, end + 1):
        if is_invalid_id(num):
            invalid_ids.append(num)
    return invalid_ids
```

**Rationale:**
- Straightforward iteration through range
- Collects all invalid IDs for potential debugging
- Could be optimized with list comprehension if memory permits

### Alternative Approaches Considered

1. **Mathematical Pattern Generation**
   - Instead of checking each number, generate valid patterns
   - E.g., for 2-digit: 11, 22, 33, ..., 99
   - For 4-digit: 1010, 1111, ..., 9999
   - **Pros:** Potentially faster for large ranges
   - **Cons:** Complex implementation, harder to verify correctness
   - **Decision:** Rejected due to complexity vs. performance trade-off

2. **Regex-based Matching**
   - Use regular expressions to match repeated patterns
   - **Pros:** Elegant pattern matching
   - **Cons:** Slower than string comparison, overkill for this problem
   - **Decision:** Rejected in favor of simple string slicing

## Package Usage

### Standard Library
- `functools.lru_cache`: Memoization for performance optimization
- `typing.List, Tuple`: Type hints for better code documentation

### External Packages
- **aocd** (`advent-of-code-data`):
  - `Puzzle(year, day)`: Fetches puzzle input automatically
  - `puzzle.input_data`: Retrieves personalized input
  - `puzzle.answer_a`: Submits Part 1 answer

- **requests**: HTTP requests to fetch problem text from website
- **beautifulsoup4**: HTML parsing for problem description extraction

### Installation
```bash
pip install advent-of-code-data requests beautifulsoup4
```

## Complexity Analysis

### Time Complexity
- **Per ID check:** O(d) where d = number of digits
- **Per range:** O(n × d) where n = range size
- **Total:** O(R × n × d) where R = number of ranges

For the example input with ranges like `11-22` (12 IDs) and `1188511880-1188511890` (11 IDs):
- Most ranges are small (< 20 IDs)
- Digit count varies from 2 to 10
- Cache hits reduce repeated computations

### Space Complexity
- **Cache:** O(k) where k ≤ 10,000 (LRU cache size)
- **Result storage:** O(m) where m = total invalid IDs found
- **Overall:** O(k + m)

## Testing Strategy

### Example Validation
The solution includes comprehensive testing:

1. **Unit Tests for Individual IDs**
   - Test known invalid IDs: 55, 6464, 123123
   - Test valid IDs: 12, 123, 1234
   - Verify edge cases

2. **Full Example Test**
   - Input: Multiple ranges from problem statement
   - Expected output: 1227775554
   - Validates end-to-end correctness

### Example Breakdown
```
Range 11-22: [11, 22] → sum = 33
Range 95-115: [99] → sum = 99
Range 998-1012: [1010] → sum = 1010
...
Total: 1227775554
```

## Best Practices Applied

1. **Modular Design**
   - Separate concerns: parsing, validation, computation
   - Easy to test and maintain

2. **Documentation**
   - Comprehensive docstrings for all functions
   - Type hints for clarity
   - Inline comments for complex logic

3. **Error Handling**
   - Try-catch blocks for network requests
   - Graceful failure for answer submission

4. **Code Reusability**
   - Generic `fetch_problem_text` function
   - Can be reused for other days

## Performance Characteristics

### Benchmark Estimates
For typical Advent of Code inputs:
- **Small ranges** (< 100 IDs): < 1ms
- **Large ranges** (< 10,000 IDs): < 100ms
- **Cache hit rate**: 0-5% (ranges rarely overlap)

### Scalability
The solution scales linearly with:
- Number of ranges
- Size of each range
- Number of digits (logarithmic in ID value)

## Inspired by Best Practices

This solution incorporates techniques from established AoC repositories:

1. **Clean structure** (inspired by fuglede/adventofcode)
   - Separate test and main execution
   - Clear function boundaries

2. **Type safety** (inspired by rHermes/adventofcode)
   - Comprehensive type hints
   - Static analysis friendly

3. **Performance optimization** (inspired by nitekat1124)
   - Strategic use of caching
   - Efficient algorithms

## Running the Solution

```bash
# Run with example tests and actual puzzle
python day2_2025.py

# Expected output:
# 1. Example test results with validation
# 2. Problem text from website
# 3. Part 1 solution and submission confirmation
```

## Future Enhancements

For Part 2 (to be revealed):
- `solve_part2` function is prepared as a placeholder
- Will follow similar modular design principles
- May reuse existing helper functions

## Conclusion

This solution demonstrates:
- **Correctness**: Validated against provided examples
- **Efficiency**: Optimized with caching and simple algorithms
- **Clarity**: Well-documented and type-safe code
- **Professionalism**: Follows best practices from expert AoC solutions

The implementation balances performance with readability, making it suitable for both competition and educational purposes.
