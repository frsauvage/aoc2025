# Day 11: Reactor - Advent of Code 2025

## Part 1: Count All Paths in a DAG

### Problem

- A reactor communicates with devices via directed connections
- Each device outputs to other devices (directed graph)
- Data flows forward only (can't flow backwards) → **DAG** (Directed Acyclic Graph)
- Goal: Count **all paths** from `you` to `out`

### Example

```
aaa: you hhh
you: bbb ccc
bbb: ddd eee
ccc: ddd eee fff
ddd: ggg
eee: out
fff: out
ggg: out
hhh: ccc fff iii
iii: out
```

**Graph visualization:**
```
       aaa ←── (label at "you")
        │
       you ────────┐
       / \         │
     bbb  ccc      │
     / \  /|\ \    │
   ddd eee fff hhh │
    |   |   |  /|\ │
   ggg  │   │ ccc fff iii
    |   │   │      │
   out  out out   out
```

**Paths from `you` to `out`:**
1. you → bbb → ddd → ggg → out
2. you → bbb → eee → out
3. you → ccc → ddd → ggg → out
4. you → ccc → eee → out
5. you → ccc → fff → out

**Answer: 5 paths**

### Solution - DFS with Backtracking

For counting all paths in a graph (with potential node reuse across different paths):
1. Start DFS from `you`
2. Track visited nodes in **current path** to avoid cycles
3. When reaching `out`, count +1
4. **Backtrack**: remove node from visited when returning

```python
def count_paths(graph, start, end, visited=None):
    if visited is None:
        visited = set()

    if start == end:
        return 1

    if start not in graph:
        return 0

    visited.add(start)
    total = 0

    for neighbor in graph[start]:
        if neighbor not in visited:
            total += count_paths(graph, neighbor, end, visited)

    visited.remove(start)  # Backtrack!
    return total
```

**Key insight**: Backtracking is essential! A node can appear in **multiple different paths**, just not in the **same path** twice.

**Complexity**: O(P) where P = number of paths (can be exponential in worst case)

---

## Part 2: Count Paths Through Required Nodes

### Problem

- Now count paths from `svr` (server rack) to `out`
- **Constraint**: Paths must visit **both** `dac` and `fft` (in any order)
- Same graph structure, different start/end and filtering requirement

### Example

```
svr: aaa bbb
aaa: fft
fft: ccc
bbb: tty
tty: ccc
ccc: ddd eee
ddd: hub
hub: fff
eee: dac
dac: fff
fff: ggg hhh
ggg: out
hhh: out
```

**All paths from `svr` to `out`:**
1. svr → aaa → **fft** → ccc → ddd → hub → fff → ggg → out
2. svr → aaa → **fft** → ccc → ddd → hub → fff → hhh → out
3. svr → aaa → **fft** → ccc → eee → **dac** → fff → ggg → out ✓
4. svr → aaa → **fft** → ccc → eee → **dac** → fff → hhh → out ✓
5. svr → bbb → tty → ccc → ddd → hub → fff → ggg → out
6. svr → bbb → tty → ccc → ddd → hub → fff → hhh → out
7. svr → bbb → tty → ccc → eee → **dac** → fff → ggg → out
8. svr → bbb → tty → ccc → eee → **dac** → fff → hhh → out

**Only paths 3 and 4 visit BOTH `dac` and `fft`!**

**Answer: 2 paths**

### Solution - DP on DAG with Bitmask

Since this is a DAG (data only flows forward), we can use **dynamic programming**:

**State**: `dp[node][mask]` = number of paths from `start` to `node` where:
- `mask` is a bitmask of which required nodes have been visited

**Transition**: Process nodes in **topological order**:
```
for each node in topo_order:
    for each neighbor of node:
        new_mask = mask | (1 << idx[neighbor]) if neighbor is required
        dp[neighbor][new_mask] += dp[node][mask]
```

**Answer**: `dp[end][full_mask]` where `full_mask` = all required nodes visited

```python
def count_paths_dp(graph, start, end, required_nodes):
    from collections import deque

    # Get all nodes
    all_nodes = set(graph.keys())
    for targets in graph.values():
        all_nodes.update(targets)

    # Build required node index
    required_list = list(required_nodes)
    required_idx = {n: i for i, n in enumerate(required_list)}

    # Topological sort (Kahn's algorithm)
    in_degree = {n: 0 for n in all_nodes}
    for src, targets in graph.items():
        for t in targets:
            in_degree[t] += 1

    queue = deque([n for n in all_nodes if in_degree[n] == 0])
    topo_order = []
    while queue:
        node = queue.popleft()
        topo_order.append(node)
        if node in graph:
            for neighbor in graph[node]:
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)

    # DP
    num_required = len(required_list)
    full_mask = (1 << num_required) - 1
    dp = {n: [0] * (full_mask + 1) for n in all_nodes}

    # Initialize start
    start_mask = 1 << required_idx[start] if start in required_idx else 0
    dp[start][start_mask] = 1

    # Process in topological order
    for node in topo_order:
        if node not in graph:
            continue
        for neighbor in graph[node]:
            add_mask = 1 << required_idx[neighbor] if neighbor in required_idx else 0
            for mask in range(full_mask + 1):
                if dp[node][mask] > 0:
                    new_mask = mask | add_mask
                    dp[neighbor][new_mask] += dp[node][mask]

    return dp[end][full_mask]
```

**Why DP instead of DFS?**
- Part 1: 574 paths → DFS with backtracking is fast
- Part 2: 306,594,217,920,240 paths → DFS would take forever!
- DP counts paths **efficiently** by combining counts at each node

---

## Algorithm Comparison

### Part 1: Simple Path Counting

| Approach | Time | When to Use |
|----------|------|-------------|
| **DFS + Backtracking** | O(V + E + P) | Small P (number of paths) |
| **DP on DAG** | O(V + E) | Any DAG |

For Part 1, P = 574 is small, so DFS works fine.

### Part 2: Constrained Path Counting

| Approach | Time | When to Use |
|----------|------|-------------|
| **DFS + filter** | O(V + E + P) | Impossible when P = 10^14! |
| **DP with bitmask** | O((V + E) × 2^k) | k = number of required nodes |

For Part 2:
- k = 2 (dac and fft)
- 2^k = 4 states per node
- O((V + E) × 4) = **linear time!**

---

## Key Concepts

### Why is this a DAG?

The problem states: "Data only ever flows from a device through its outputs; it can't flow backwards."

This means:
- No cycles in the graph
- Can use topological sort
- DP is guaranteed to work

### Topological Sort (Kahn's Algorithm)

1. Compute in-degree for each node
2. Start with nodes having in-degree 0
3. Process node, decrement neighbors' in-degree
4. Add neighbors with in-degree 0 to queue
5. Result: nodes in valid processing order

```python
# Kahn's algorithm
in_degree = {n: 0 for n in all_nodes}
for src, targets in graph.items():
    for t in targets:
        in_degree[t] += 1

queue = deque([n for n in all_nodes if in_degree[n] == 0])
topo_order = []
while queue:
    node = queue.popleft()
    topo_order.append(node)
    for neighbor in graph.get(node, []):
        in_degree[neighbor] -= 1
        if in_degree[neighbor] == 0:
            queue.append(neighbor)
```

**Complexity**: O(V + E)

### Bitmask DP

Track which required nodes have been visited using bits:
- `dac` visited → bit 0 set → mask = 0b01 = 1
- `fft` visited → bit 1 set → mask = 0b10 = 2
- Both visited → mask = 0b11 = 3

```python
# Check if node is required and update mask
if neighbor in required_idx:
    add_mask = 1 << required_idx[neighbor]
new_mask = mask | add_mask
```

---

## Complexity Analysis

### Part 1
- **Time**: O(V + E + P) where P = paths found
- **Space**: O(V) for visited set + recursion stack
- P = 574 → milliseconds

### Part 2
- **Time**: O((V + E) × 2^k) where k = required nodes
- **Space**: O(V × 2^k) for DP table
- V ≈ 650, E ≈ 2000, k = 2 → O(10,000) → milliseconds

**Why Part 2 needs DP:**
- Answer is 306,594,217,920,240 paths
- DFS would enumerate each path: ~10^14 operations
- At 10^9 ops/sec: would take **10 years!**
- DP counts without enumerating: **instant**

---

## Common Pitfalls

### Part 1: Forgetting to Backtrack

**Wrong:**
```python
visited.add(start)
for neighbor in graph[start]:
    if neighbor not in visited:
        total += count_paths(graph, neighbor, end, visited)
# Missing: visited.remove(start)
```

This would undercount because nodes used in one path can't be used in others.

### Part 2: Using DFS Instead of DP

DFS with required node filtering would work **correctly** but be **impossibly slow** for 10^14 paths.

### Part 2: Not Detecting DAG Property

If the graph had cycles, DP wouldn't work. We'd need:
- Cycle detection first
- Different algorithm (Johnson's all paths)

---

## Connection to Classic Problems

### All Paths in DAG
- Classic DP problem
- Count: O(V + E) with DP
- Enumerate: O(V + E + P) with DFS

### Constrained Path Counting
- Extension of "number of paths through vertex v"
- Bitmask DP for multiple constraints
- Related to: shortest path with required waypoints

### Topological Sort Applications
- Build systems (make, gradle)
- Task scheduling
- Course prerequisites
- Package dependencies

---

## Answers

- **Part 1**: 574 (all paths from `you` to `out`)
- **Part 2**: 306594217920240 (paths from `svr` to `out` visiting both `dac` and `fft`)

### Why Such a Large Answer for Part 2?

The graph has many branching points:
- ~650 devices
- ~2000 connections
- Paths can branch and reconverge many times

The number of paths grows **exponentially** with graph depth.
DP handles this by storing **counts** instead of **enumeration**.
