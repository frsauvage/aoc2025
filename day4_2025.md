# Day 4: Printing Department - Advent of Code 2025

## Part 1: Accessible Paper Rolls

### Problem

- Grid of paper rolls marked as `@`
- A forklift can access a roll only if it has **fewer than 4 neighbors** in the 8 adjacent positions (including diagonals)
- Count how many rolls can be accessed

### Example

```
..@@.@@@@.
@@@.@.@.@@
@@@@@.@.@@
@.@@@@..@.
@@.@@@@.@@
.@@@@@@@.@
.@.@.@.@@@
@.@@@.@@@@
.@@@@@@@@.
@.@.@@@.@.
```

Result: **13** accessible rolls (marked as `x` in the original)

### Solution - Grid Neighbor Counting

**Algorithm:** 8-directional adjacency check

**Approach:**
1. Parse grid into set of coordinates for O(1) lookup
2. For each roll position, count neighbors in 8 directions
3. Count positions with `< 4` neighbors

**Data Structure:** `set()` of `(row, col)` tuples for efficient neighbor checks

```python
DIRECTIONS = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]

def parse_rolls(data):
    """Parse grid and extract all paper roll positions."""
    lines = data.strip().split('\n')
    return {(r, c) for r, line in enumerate(lines)
            for c, char in enumerate(line) if char == '@'}

def count_neighbors(pos, rolls):
    """Count how many neighbors a position has."""
    r, c = pos
    return sum(1 for dr, dc in DIRECTIONS if (r + dr, c + dc) in rolls)

def find_accessible(rolls):
    """Find all rolls with fewer than 4 neighbors."""
    return {pos for pos in rolls if count_neighbors(pos, rolls) < 4}

def solve_part1(data):
    rolls = parse_rolls(data)
    return len(find_accessible(rolls))
```

**Complexity:** O(n) where n = number of rolls

---

## Part 2: Iterative Removal

### Problem

- Once a roll is **removed**, more rolls might become accessible
- Keep removing accessible rolls until none remain
- Count total rolls removed

### Example Process

```
Initial: 67 rolls ‚Üí Remove 13 accessible
After 1: 54 rolls ‚Üí Remove 12 accessible
After 2: 42 rolls ‚Üí Remove 7 accessible
After 3: 35 rolls ‚Üí Remove 5 accessible
After 4: 30 rolls ‚Üí Remove 2 accessible
After 5: 28 rolls ‚Üí Remove 1 accessible
After 6: 27 rolls ‚Üí Remove 1 accessible
After 7: 26 rolls ‚Üí Remove 1 accessible
After 8: 25 rolls ‚Üí Remove 1 accessible
Final:   25 rolls remain (all with >= 4 neighbors)

Total removed: 43
```

### Solution - Iterative Simulation (Cellular Automaton)

**Algorithm:** Repeated batch removal until convergence

**Approach:**
1. Find all rolls with `< 4` neighbors (accessible set)
2. If none found, stop
3. Remove all accessible rolls simultaneously
4. Recalculate neighbors for remaining rolls
5. Repeat until no more removals possible

```python
def solve_part2(data):
    rolls = parse_rolls(data)
    total_removed = 0

    while True:
        accessible = find_accessible(rolls)
        if not accessible:
            break

        rolls -= accessible
        total_removed += len(accessible)

    return total_removed
```

**Complexity:** O(k √ó n) where:
- k = number of iterations (removal rounds)
- n = number of rolls

---

## Key Insights

### Why Use a Set?
- **O(1) neighbor lookup** vs O(n) for list scanning
- **Efficient bulk removal** with set subtraction: `rolls -= accessible`
- Natural representation of sparse grids

### Why Batch Removal?
- Removing one-by-one would change neighbor counts mid-iteration
- Simultaneous removal ensures consistent neighbor calculations
- Similar to Conway's Game of Life update strategy

### Algorithm Classification
This is a **cellular automaton-like** simulation where:
- Each cell (roll) has a state based on local neighborhood
- State transitions happen synchronously
- System evolves until reaching a stable configuration

---

## Answers

- **Part 1**: 1551 accessible rolls
- **Part 2**: 9784 total rolls removed

---

## Code Refactoring

### Initial Implementation Issues
- Code duplication between Part 1 and Part 2
- Grid parsing repeated in both functions
- Accessible roll finding logic duplicated

### What is DRY Principle?

**DRY = "Don't Repeat Yourself"**

> "Every piece of knowledge must have a single, unambiguous, authoritative representation within a system."
> ‚Äî The Pragmatic Programmer (1999)

**Core idea:** Each logic/knowledge should exist at **one single place** in the code.

### Why DRY Matters

#### ‚ùå Before (WET - "Write Everything Twice")
```python
def solve_part1(data):
    # Parse grid (DUPLICATION #1)
    lines = data.strip().split('\n')
    rolls = set()
    for r, line in enumerate(lines):
        for c, char in enumerate(line):
            if char == '@':
                rolls.add((r, c))

    # Find accessible (DUPLICATION #2)
    accessible = 0
    for pos in rolls:
        if count_neighbors(pos, rolls) < 4:
            accessible += 1
    return accessible

def solve_part2(data):
    # SAME parsing logic repeated!!!
    lines = data.strip().split('\n')
    rolls = set()
    for r, line in enumerate(lines):
        for c, char in enumerate(line):
            if char == '@':
                rolls.add((r, c))

    total_removed = 0
    while True:
        # SAME accessible logic repeated!!!
        accessible = set()
        for pos in rolls:
            if count_neighbors(pos, rolls) < 4:
                accessible.add(pos)
        if not accessible:
            break
        rolls -= accessible
        total_removed += len(accessible)
    return total_removed
```

**Problems:**
- Parsing logic exists in 2 places
- "< 4 neighbors" logic exists in 2 places
- If we need to change the criterion ‚Üí must modify 2 places
- High risk of bugs (forgetting to update one place)

#### ‚úÖ After (DRY)
```python
def parse_rolls(data):
    """ONE single source of truth for parsing."""
    lines = data.strip().split('\n')
    return {(r, c) for r, line in enumerate(lines)
            for c, char in enumerate(line) if char == '@'}

def find_accessible(rolls):
    """ONE single source of truth for accessibility logic."""
    return {pos for pos in rolls if count_neighbors(pos, rolls) < 4}

def solve_part1(data):
    rolls = parse_rolls(data)
    return len(find_accessible(rolls))

def solve_part2(data):
    rolls = parse_rolls(data)
    total_removed = 0
    while True:
        accessible = find_accessible(rolls)
        if not accessible:
            break
        rolls -= accessible
        total_removed += len(accessible)
    return total_removed
```

**Example: Changing the criterion**

Imagine the problem changes and rolls are now accessible with **< 3 neighbors**:

- **WET approach:** Must change in 2 places (risk of forgetting one!)
- **DRY approach:** Change only `find_accessible()` ‚Üí done! ‚úÖ

### Refactored Solution (DRY Principle)

**Extracted Helper Functions:**

1. **`parse_rolls(data)`** - Single responsibility: parse grid
   - Eliminates duplicate parsing logic
   - Returns clean `set()` of coordinates

2. **`find_accessible(rolls)`** - Single responsibility: find accessible rolls
   - Encapsulates the "< 4 neighbors" logic
   - Reusable in both parts

3. **`count_neighbors(pos, rolls)`** - Simplified with `sum()`
   - Uses generator expression instead of manual loop
   - More Pythonic and concise

**Benefits:**
- ‚úÖ `solve_part1()`: **2 lines** instead of 15
- ‚úÖ `solve_part2()`: **8 lines** instead of 20
- ‚úÖ Code more readable and maintainable
- ‚úÖ Functions are testable independently
- ‚úÖ Same performance, cleaner implementation
- ‚úÖ Single source of truth for each logic
- ‚úÖ Easier to modify and maintain

### Other Programming Principles

| Principle | Acronym | Meaning |
|-----------|---------|---------|
| **DRY** | Don't Repeat Yourself | No code duplication |
| **WET** | Write Everything Twice | Anti-pattern (bad) |
| **KISS** | Keep It Simple, Stupid | Simplicity over complexity |
| **YAGNI** | You Aren't Gonna Need It | Don't add unused features |
| **SOLID** | 5 OOP principles | Single Responsibility, etc. |

**Rule of thumb:** If you copy-paste code ‚Üí create a function instead! üéØ

---

## Related Algorithms

- **Cellular Automaton**: Conway's Game of Life, forest fire models
- **Percolation Theory**: Similar removal/accessibility patterns
- **Graph Connectivity**: Could model as graph where edges exist between neighbors
