# Day 4: Printing Department - Advent of Code 2025

## Problem Overview

In the printing department, paper rolls are stored in a grid. A forklift needs to access rolls for removal, but can only reach rolls that have fewer than 4 neighbors (8-directional adjacency). The challenge is to identify accessible rolls and simulate their iterative removal.

### Problem Details

**Part 1: Accessible Paper Rolls**
- Grid of paper rolls marked as `@`
- A forklift can access a roll only if it has **fewer than 4 neighbors** in the 8 adjacent positions (including diagonals)
- Count how many rolls can be accessed

**Part 2: Iterative Removal**
- Once a roll is **removed**, more rolls might become accessible
- Keep removing accessible rolls until none remain
- Count total rolls removed

### Example

```
Initial grid:
..@@.@@@@.
@@@.@.@.@@
@@@@@.@.@@
@.@@@@..@.
@@.@@@@.@@
.@@@@@@@.@
.@.@.@.@@@
@.@@@.@@@@
.@@@@@@@@.
@.@.@@@.@.
```

**Part 1 Analysis:**

Accessible rolls visualization (marked with `x` have < 4 neighbors):

```
..xx.xxxxx
xxx.x.x.xx
xxxxx.x.xx
x.xxxx..x.
xx.xxxx.xx
.xxxxxxx.x
.x.x.x.xxx
x.xxx.xxxx
.xxxxxxxx.
x.x.xxx.x.
```

Result: **13** accessible rolls

**Detailed example analysis:**
- Position (0,2): `@` has 2 neighbors â†’ accessible âœ“
- Position (1,0): `@` has 2 neighbors â†’ accessible âœ“
- Position (5,1): `@` has 7 neighbors â†’ NOT accessible âœ—
- Position (3,7): `.` (empty) â†’ not a roll

**Part 2 Analysis:**

Starting from the same 10Ã—10 grid with 67 total rolls.

**Round 1:** Remove 13 accessible rolls
```
..@@.@@@@.     â†’     ..xx.xxxxx
@@@.@.@.@@            xxx.x.x.xx
@@@@@.@.@@            xxxxx.x.xx
@.@@@@..@.            x.xxxx..x.
@@.@@@@.@@            xx.xxxx.xx
.@@@@@@@.@            .xxxxxxx.x
.@.@.@.@@@            .x.x.x.xxx
@.@@@.@@@@            x.xxx.xxxx
.@@@@@@@@.            .xxxxxxxx.
@.@.@@@.@.            x.x.xxx.x.
```

**Round 2:** After removal, 12 more become accessible

**Subsequent rounds:** Continue until convergence
- Round 3: Remove 7 rolls
- Round 4: Remove 5 rolls
- Round 5: Remove 2 rolls
- Round 6-9: Remove 1 roll each

**Final state:** 25 rolls remain (all with >= 4 neighbors)
```
..........
..x.......
.xxx......
..xxx.....
...xxxx...
...xxxxx..
...x.x.xx.
...xx.xxx.
...xxxxxx.
....xxx...
```

**Summary:**
- Initial: 67 rolls
- Total removed: **43 rolls**
- Remaining: 25 rolls (densely packed, all with >= 4 neighbors)

---

## Solution Approach

### Algorithms

**Part 1 Strategy:** Grid traversal + neighbor counting (8-directional adjacency)
- Parse grid into set of coordinates for O(1) lookup
- For each roll position, count neighbors in 8 directions
- Count positions with `< 4` neighbors

**Part 2 Strategy:** Iterative simulation (cellular automaton-like removal)
- Repeatedly find all rolls with < 4 neighbors
- Remove them simultaneously
- Recalculate neighbors for remaining rolls
- Continue until no more can be removed

**Complexity:**
- Part 1: O(n) where n = number of rolls
- Part 2: O(k Ã— n) where k = number of iterations, n = number of rolls

### Algorithm Details

#### Part 1: Grid Neighbor Counting

```python
DIRECTIONS = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]

def parse_rolls(data):
    """Parse grid and extract all paper roll positions."""
    lines = data.strip().split('\n')
    return {(r, c) for r, line in enumerate(lines)
            for c, char in enumerate(line) if char == '@'}

def count_neighbors(pos, rolls):
    """Count how many neighbors a position has."""
    r, c = pos
    return sum(1 for dr, dc in DIRECTIONS if (r + dr, c + dc) in rolls)

def find_accessible(rolls):
    """Find all rolls with fewer than 4 neighbors."""
    return {pos for pos in rolls if count_neighbors(pos, rolls) < 4}

def solve_part1(data):
    rolls = parse_rolls(data)
    return len(find_accessible(rolls))
```

#### Part 2: Iterative Simulation

```python
def solve_part2(data):
    rolls = parse_rolls(data)
    total_removed = 0

    while True:
        accessible = find_accessible(rolls)
        if not accessible:
            break

        rolls -= accessible
        total_removed += len(accessible)

    return total_removed
```

### Key Algorithmic Decisions

**1. Use Set for Coordinate Storage**

**Why `set()` instead of `list`?**
- O(1) neighbor lookup vs O(n) for list scanning
- Efficient bulk removal with set subtraction: `rolls -= accessible`
- Natural representation of sparse grids

**2. Batch Removal Strategy**

**Why remove all simultaneously?**
- Removing one-by-one would change neighbor counts mid-iteration
- Simultaneous removal ensures consistent neighbor calculations
- Similar to Conway's Game of Life update strategy

**3. 8-Directional Adjacency**

```python
DIRECTIONS = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]
```

All 8 neighbors (including diagonals) must be checked.

**4. Termination Condition**

Loop continues until `find_accessible(rolls)` returns empty set, meaning all remaining rolls have >= 4 neighbors (stable configuration).

### Complexity Analysis

#### Part 1

- Parse grid: O(n Ã— m) where n = rows, m = columns
- Build set: O(k) where k = number of rolls
- Count neighbors for each roll: O(k Ã— 8) = O(k)
- **Total:** O(n Ã— m + k) â‰ˆ **O(k)** where k = number of rolls

#### Part 2

- Initial setup: O(k)
- Each iteration:
  - Find accessible: O(k)
  - Remove accessible: O(a) where a = accessible count
  - Total iterations: i (unknown, depends on grid structure)
- **Total:** O(i Ã— k)

**For real input:** ~10 iterations Ã— ~1000 rolls = ~10,000 operations (very fast)

### Python Dependencies Used

```python
from aocd import get_data, submit  # For AoC integration
```

**Built-in data structures:**
- `set` - for O(1) coordinate lookup
- `tuple` - for (row, col) coordinates
- `list` - for parsing grid lines

---

## Implementation Details

### Dependencies

```python
from aocd import get_data, submit
```

**No external libraries needed** - solution uses only built-in Python.

### Code Structure

```
day4_2025.py
â”œâ”€â”€ DIRECTIONS              # 8-directional adjacency constant
â”œâ”€â”€ parse_rolls(data)       # Parse grid into set of coordinates
â”œâ”€â”€ count_neighbors(pos, rolls)  # Count 8-directional neighbors
â”œâ”€â”€ find_accessible(rolls)  # Find rolls with < 4 neighbors
â”œâ”€â”€ solve_part1(data)       # Count accessible rolls
â”œâ”€â”€ solve_part2(data)       # Iterative removal simulation
â””â”€â”€ __main__                # Test cases and submission
```

---

## Running the Solution

```bash
# Run solution
python day4_2025.py

# Output:
# Part 1 example: 13 (expected: 13)
# Part 2 example: 43 (expected: 43)
#
# Part 1 answer: 1551
# Part 2 answer: 9784
```

**Test cases included:**
- Part 1 example: expects 13 accessible rolls
- Part 2 example: expects 43 total removed

---

## Best Practices Demonstrated

### 1. DRY Principle (Don't Repeat Yourself)

**Initial Implementation Issues:**
- Code duplication between Part 1 and Part 2
- Grid parsing repeated in both functions
- Accessible roll finding logic duplicated

#### âŒ Before (WET - "Write Everything Twice")

```python
def solve_part1(data):
    # Parse grid (DUPLICATION #1)
    lines = data.strip().split('\n')
    rolls = set()
    for r, line in enumerate(lines):
        for c, char in enumerate(line):
            if char == '@':
                rolls.add((r, c))

    # Find accessible (DUPLICATION #2)
    accessible = 0
    for pos in rolls:
        if count_neighbors(pos, rolls) < 4:
            accessible += 1
    return accessible

def solve_part2(data):
    # SAME parsing logic repeated!!!
    lines = data.strip().split('\n')
    rolls = set()
    for r, line in enumerate(lines):
        for c, char in enumerate(line):
            if char == '@':
                rolls.add((r, c))

    total_removed = 0
    while True:
        # SAME accessible logic repeated!!!
        accessible = set()
        for pos in rolls:
            if count_neighbors(pos, rolls) < 4:
                accessible.add(pos)
        if not accessible:
            break
        rolls -= accessible
        total_removed += len(accessible)
    return total_removed
```

**Problems:**
- Parsing logic exists in 2 places
- "< 4 neighbors" logic exists in 2 places
- If we need to change the criterion â†’ must modify 2 places
- High risk of bugs (forgetting to update one place)

#### âœ… After (DRY)

```python
def parse_rolls(data):
    """ONE single source of truth for parsing."""
    lines = data.strip().split('\n')
    return {(r, c) for r, line in enumerate(lines)
            for c, char in enumerate(line) if char == '@'}

def find_accessible(rolls):
    """ONE single source of truth for accessibility logic."""
    return {pos for pos in rolls if count_neighbors(pos, rolls) < 4}

def solve_part1(data):
    rolls = parse_rolls(data)
    return len(find_accessible(rolls))

def solve_part2(data):
    rolls = parse_rolls(data)
    total_removed = 0
    while True:
        accessible = find_accessible(rolls)
        if not accessible:
            break
        rolls -= accessible
        total_removed += len(accessible)
    return total_removed
```

**Benefits:**
- âœ… `solve_part1()`: **2 lines** instead of 15
- âœ… `solve_part2()`: **8 lines** instead of 20
- âœ… Code more readable and maintainable
- âœ… Functions are testable independently
- âœ… Same performance, cleaner implementation
- âœ… Single source of truth for each logic

**Example: Changing the criterion**

Imagine the problem changes and rolls are now accessible with **< 3 neighbors**:
- **WET approach:** Must change in 2 places (risk of forgetting one!)
- **DRY approach:** Change only `find_accessible()` â†’ done! âœ…

### 2. Set Operations for Efficiency

```python
# Efficient set subtraction
rolls -= accessible  # O(len(accessible))

# vs inefficient list approach
for pos in accessible:
    rolls.remove(pos)  # O(len(accessible)^2)
```

### 3. Generator Expressions

```python
# Concise and memory-efficient
return sum(1 for dr, dc in DIRECTIONS if (r + dr, c + dc) in rolls)

# vs verbose loop
count = 0
for dr, dc in DIRECTIONS:
    if (r + dr, c + dc) in rolls:
        count += 1
return count
```

### 4. Set Comprehensions

```python
# Elegant and readable
return {(r, c) for r, line in enumerate(lines)
        for c, char in enumerate(line) if char == '@'}

# vs manual loop
rolls = set()
for r, line in enumerate(lines):
    for c, char in enumerate(line):
        if char == '@':
            rolls.add((r, c))
return rolls
```

### 5. Clear Function Responsibilities

Each function has a single, clear purpose:
- `parse_rolls()` - parsing only
- `count_neighbors()` - counting only
- `find_accessible()` - filtering only
- `solve_part1/2()` - orchestration only

---

## Programming Principles

| Principle | Acronym | Meaning |
|-----------|---------|---------|
| **DRY** | Don't Repeat Yourself | No code duplication |
| **WET** | Write Everything Twice | Anti-pattern (bad) |
| **KISS** | Keep It Simple, Stupid | Simplicity over complexity |
| **YAGNI** | You Aren't Gonna Need It | Don't add unused features |
| **SOLID** | 5 OOP principles | Single Responsibility, etc. |

**Rule of thumb:** If you copy-paste code â†’ create a function instead! ðŸŽ¯

---

## Algorithm Classification

This problem is a **cellular automaton-like** simulation where:
- Each cell (roll) has a state based on local neighborhood
- State transitions happen synchronously
- System evolves until reaching a stable configuration

### Related Algorithms

- **Cellular Automaton**: Conway's Game of Life, forest fire models
- **Percolation Theory**: Similar removal/accessibility patterns
- **Graph Connectivity**: Could model as graph where edges exist between neighbors

---

## References

### Similar Problems

- **Conway's Game of Life** - Cellular automaton with neighbor-based rules
- **Percolation Theory** - Study of connectivity in random graphs
- **Grid-based pathfinding** - BFS/DFS on 8-directional grids

### Further Reading

- [Cellular Automaton (Wikipedia)](https://en.wikipedia.org/wiki/Cellular_automaton)
- [Percolation Theory](https://en.wikipedia.org/wiki/Percolation_theory)
- [Graph Connectivity](https://en.wikipedia.org/wiki/Connectivity_(graph_theory))

---

## Answers

- **Part 1**: 1,551 accessible rolls
- **Part 2**: 9,784 total rolls removed

---

## Conclusion

This problem demonstrates key concepts in **grid-based simulations** and **iterative algorithms**:

**Key Takeaways:**

1. **Set operations** enable efficient coordinate-based grid manipulation
2. **DRY principle** reduces code size and improves maintainability
3. **Batch updates** ensure consistency in cellular automaton simulations
4. **Iterative convergence** is a natural pattern for stability problems

**Design Patterns:**

- Extracting helper functions (parse, count, find)
- Using appropriate data structures (set for O(1) lookup)
- Synchronous state updates (remove all accessible simultaneously)
- Clear termination conditions (empty accessible set)

The solution exemplifies how **clean code organization** and **appropriate data structures** can make complex simulations simple and efficient.
