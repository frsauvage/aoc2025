# Day 5: Cafeteria - Advent of Code 2025

## Problem Overview

The Elves in the cafeteria kitchen need help with their new inventory management system. They can't determine which ingredients are fresh vs spoiled based on their database of ID ranges.

### Problem Details

**Part 1: Fresh Ingredient Detection**
- Kitchen has a database with **fresh ingredient ID ranges**
- Need to check which **available ingredient IDs** are fresh
- An ingredient is fresh if it falls into **any** range (ranges can overlap)
- Ranges are **inclusive**: `3-5` means IDs 3, 4, and 5 are all fresh

**Part 2: Total Fresh IDs in Ranges**
- Ignore the available ingredient IDs list
- Count **all unique IDs** covered by the fresh ranges
- Ranges can **overlap**, so need to avoid double-counting
- Must merge overlapping/adjacent ranges first

### Example

```
3-5
10-14
16-20
12-18

1
5
8
11
17
32
```

**Part 1 Analysis:**

Fresh ID ranges:
- `3-5`: covers IDs 3, 4, 5
- `10-14`: covers IDs 10, 11, 12, 13, 14
- `16-20`: covers IDs 16, 17, 18, 19, 20
- `12-18`: covers IDs 12, 13, 14, 15, 16, 17, 18 (overlaps with others)

Available ingredient IDs check:
- `1`: ❌ Spoiled (not in any range)
- `5`: ✅ Fresh (in range `3-5`)
- `8`: ❌ Spoiled (not in any range)
- `11`: ✅ Fresh (in range `10-14`)
- `17`: ✅ Fresh (in ranges `16-20` and `12-18`)
- `32`: ❌ Spoiled (not in any range)

**Result:** **3** fresh ingredients

**Part 2 Analysis:**

Step 1: Sort ranges
```
3-5
10-14
12-18    (overlaps with 10-14)
16-20    (overlaps with 12-18)
```

Step 2: Merge overlapping/adjacent ranges
- `3-5`: standalone → keep as is
- `10-14` and `12-18`: overlap (14 ≥ 12) → merge to `10-18`
- `10-18` and `16-20`: overlap (18 ≥ 16) → merge to `10-20`

Merged ranges:
```
3-5      → 3 IDs (5 - 3 + 1)
10-20    → 11 IDs (20 - 10 + 1)
```

**Result:** 3 + 11 = **14** unique fresh IDs

---

## Solution Approach

### Algorithms

**Part 1 Strategy:** Linear scan with early exit
- Parse ranges and ingredient IDs from input
- For each ingredient ID, check if it falls in any range
- Use early exit optimization: stop checking once found in a range
- Count total fresh ingredients

**Part 2 Strategy:** Interval merging (greedy algorithm)
- Parse ranges from input
- Sort ranges by start position
- Merge overlapping or adjacent ranges in a single pass
- Count total IDs in merged ranges

**Complexity:**
- Part 1: O(n × m) where n = ingredient IDs, m = ranges
- Part 2: O(r log r) where r = number of ranges (dominated by sorting)

### Algorithm Details

#### Part 1: Range Membership Check

```python
def solve_part1(data):
    lines = data.strip().split('\n')

    # Find the blank line separating ranges from IDs
    blank_idx = lines.index('')

    # Parse ranges
    ranges = []
    for line in lines[:blank_idx]:
        start, end = map(int, line.split('-'))
        ranges.append((start, end))

    # Parse ingredient IDs
    ingredient_ids = [int(line) for line in lines[blank_idx + 1:]]

    # Count fresh ingredients
    fresh_count = 0
    for ingredient_id in ingredient_ids:
        for start, end in ranges:
            if start <= ingredient_id <= end:
                fresh_count += 1
                break  # Early exit - found in at least one range

    return fresh_count
```

#### Part 2: Interval Merging

```python
def solve_part2(data):
    lines = data.strip().split('\n')

    # Find the blank line separating ranges from IDs
    blank_idx = lines.index('')

    # Parse ranges
    ranges = []
    for line in lines[:blank_idx]:
        start, end = map(int, line.split('-'))
        ranges.append((start, end))

    # Sort ranges by start position
    ranges.sort()

    # Merge overlapping/adjacent ranges
    merged = []
    for start, end in ranges:
        if merged and start <= merged[-1][1] + 1:
            # Overlapping or adjacent - extend last range
            merged[-1] = (merged[-1][0], max(merged[-1][1], end))
        else:
            # Non-overlapping - add new range
            merged.append((start, end))

    # Count total IDs in merged ranges
    total = 0
    for start, end in merged:
        total += end - start + 1

    return total
```

### Key Algorithmic Decisions

**1. Range Overlap Detection**

Condition for overlap/adjacency:
```python
start₂ <= end₁ + 1
```

Examples:
- `[3-5]` and `[6-8]`: 6 ≤ 5 + 1 → adjacent ✅
- `[3-5]` and `[7-9]`: 7 ≤ 5 + 1 → not adjacent ❌
- `[3-5]` and `[4-8]`: 4 ≤ 5 + 1 → overlapping ✅

**2. Merging Logic**

When merging `[a, b]` and `[c, d]`:
```python
merged_range = (a, max(b, d))
```

**Why `max(b, d)`?** The second range might be contained in the first:
- `[3-10]` and `[5-8]` → merge to `[3-10]` (not `[3-8]`)

**3. Sorting Enables Greedy**

Without sorting, we'd miss merges:
```
Bad order: [10-14], [3-5], [12-18]
→ Can't detect that 10-14 and 12-18 should merge

Good order: [3-5], [10-14], [12-18]
→ Sequential processing catches all merges
```

**4. Single-Pass Merging**

Once ranges are sorted, a **single pass** is sufficient:
- Process left-to-right
- Always merge with the last range in result
- No need to backtrack or re-check

### Complexity Analysis

#### Part 1

| Operation | Complexity |
|-----------|-----------|
| Parse input | O(r + i) |
| Check each ID | O(i × r) |
| **Total** | **O(i × r)** |

Where: i = ingredient IDs, r = ranges

**For real input:** ~200 IDs × ~50 ranges = ~10,000 checks (fast)

#### Part 2

| Operation | Complexity |
|-----------|-----------|
| Parse input | O(r) |
| Sort ranges | O(r log r) |
| Merge ranges | O(r) |
| Count IDs | O(r) |
| **Total** | **O(r log r)** |

**Optimization:** Sorting is the bottleneck, but r is small (~50 ranges)

### Python Dependencies Used

```python
# Built-in Python only - no external dependencies
from aocd import get_data, submit  # For AoC integration only
```

**Data structures:**
- `list` - for storing ranges and IDs
- `tuple` - for representing (start, end) ranges
- `int` - for ingredient IDs

---

## Implementation Details

### Dependencies

```python
from aocd import get_data, submit
```

**No external libraries needed** - solution uses only built-in Python.

### Code Structure

```
day5.py
├── solve_part1(data)      # Range membership checking
├── solve_part2(data)      # Interval merging
└── __main__               # Test cases and submission
```

**Helper functions (recommended refactoring):**

```python
def parse_input(data):
    """Parse ranges and ingredient IDs from input."""
    lines = data.strip().split('\n')
    blank_idx = lines.index('')

    ranges = [tuple(map(int, line.split('-'))) for line in lines[:blank_idx]]
    ingredient_ids = [int(line) for line in lines[blank_idx + 1:]]

    return ranges, ingredient_ids

def is_fresh(ingredient_id, ranges):
    """Check if an ingredient ID is in any range."""
    return any(start <= ingredient_id <= end for start, end in ranges)

def merge_ranges(ranges):
    """Merge overlapping and adjacent ranges."""
    sorted_ranges = sorted(ranges)
    merged = []

    for start, end in sorted_ranges:
        if merged and start <= merged[-1][1] + 1:
            merged[-1] = (merged[-1][0], max(merged[-1][1], end))
        else:
            merged.append((start, end))

    return merged

def count_range_ids(ranges):
    """Count total IDs covered by ranges."""
    return sum(end - start + 1 for start, end in ranges)
```

**Refactored solutions:**

```python
def solve_part1(data):
    ranges, ingredient_ids = parse_input(data)
    return sum(1 for id in ingredient_ids if is_fresh(id, ranges))

def solve_part2(data):
    ranges, _ = parse_input(data)
    merged = merge_ranges(ranges)
    return count_range_ids(merged)
```

---

## Running the Solution

```bash
# Run with example
python day5.py

# Output:
# Example result: 3
# Part 1: 556
# Example Part 2 result: 14
# Part 2: 10686195
```

**Test cases included:**
- Part 1 example: expects 3 fresh ingredients
- Part 2 example: expects 14 total fresh IDs

---

## Best Practices Demonstrated

### 1. DRY Principle (Refactored Version)
- Parsing logic extracted to `parse_input()`
- Range checking extracted to `is_fresh()`
- Merging logic extracted to `merge_ranges()`

### 2. Early Exit Optimization
```python
for start, end in ranges:
    if start <= ingredient_id <= end:
        fresh_count += 1
        break  # ← Stop checking once found
```

### 3. Work with Endpoints, Not Elements

❌ **Bad approach** (memory intensive):
```python
all_ids = set()
for start, end in ranges:
    all_ids.update(range(start, end + 1))  # Creates millions of elements!
return len(all_ids)
```

✅ **Good approach** (efficient):
```python
total = 0
for start, end in merged:
    total += end - start + 1  # Just arithmetic
return total
```

**Lesson:** Range `1-10000000` would create 10M elements in memory. Work with range endpoints instead.

### 4. Greedy Algorithm Correctness

The interval merging uses a greedy approach:
- Sort intervals by start position
- Always try to merge with the last interval in result
- This is **provably correct** for the interval merging problem

### 5. Clear Variable Names
- `ranges` - list of (start, end) tuples
- `ingredient_ids` - list of IDs to check
- `merged` - result of merging overlapping ranges
- `blank_idx` - separator between ranges and IDs

---

## Visual Example: Merging Process

```
Input ranges (unsorted):
  3━━━5
       10━━━━━━14
              12━━━━━━━━18
                     16━━━━━━━20

Step 1: Sort by start
  3━━━5
       10━━━━━━14
              12━━━━━━━━18
                     16━━━━━━━20

Step 2: Merge overlaps
  3━━━5
       10━━━━━━━━━━━━━━━━━━20
                    (merged 10-14, 12-18, 16-20)

Final result: 2 ranges
  [3-5]: 3 IDs
  [10-20]: 11 IDs
  Total: 14 IDs
```

---

## Alternative Approaches

### Part 1: Binary Search (Not Worth It)

If ranges were sorted and non-overlapping, could use binary search for O(log r) per ID.

**Verdict:** Not worth it here because:
- Ranges overlap (requires additional handling)
- Dataset is small (~200 IDs × ~50 ranges = fast anyway)
- Complexity of implementation > benefit

### Part 2: Explicit Set Enumeration (Too Slow)

```python
# DON'T DO THIS - very slow for large ranges!
all_ids = set()
for start, end in ranges:
    all_ids.update(range(start, end + 1))
return len(all_ids)
```

**Why bad?** Range `1-10000000` would create 10M elements in memory.

**Time complexity:** O(total_range_size) - can be huge!
**Space complexity:** O(total_range_size) - wasteful

**Lesson:** Work with range endpoints, not individual elements.

---

## References

### Related Algorithms

**Interval Merging:**
- Classic problem: [Merge Intervals (LeetCode #56)](https://leetcode.com/problems/merge-intervals/)
- Applications:
  - Calendar scheduling (merge meeting times)
  - IP address range consolidation
  - Memory allocation (merge free blocks)

**Range Query:**
- Part 1 approach: Linear scan (simple but O(n×m))
- Alternative: Interval tree for O(log n) queries
  - Only worth it if querying many times
  - For one-time checks, linear is fine

**Sweep Line Algorithm:**
- Sort events (range starts/ends)
- Process left-to-right
- Track current coverage
- Used in computational geometry

**Set Cover Problem:**
- Part 2 is essentially: "Which IDs are covered by any range?"
- Related to: union of intervals
- Greedy solution works when intervals are on a line

### Further Reading

- [Interval Scheduling](https://en.wikipedia.org/wiki/Interval_scheduling)
- [Greedy Algorithms](https://en.wikipedia.org/wiki/Greedy_algorithm)
- [Computational Geometry](https://en.wikipedia.org/wiki/Computational_geometry)

---

## Answers

- **Part 1**: 556 fresh ingredients
- **Part 2**: 10,686,195 total fresh IDs

---

## Conclusion

This problem teaches fundamental **interval/range manipulation** - a common pattern in:
- Scheduling and resource allocation
- Network and IP address management
- Memory management systems
- Computational geometry

**Key Takeaways:**

1. **Part 1**: Simple iteration with early exit is sufficient
2. **Part 2**: Interval merging is a classic greedy algorithm
3. **Sorting unlocks greedy approach**: Process intervals left-to-right
4. **Work with endpoints, not elements**: Avoid materializing huge ranges
5. **One-pass merging**: After sorting, no backtracking needed

The greedy interval merging algorithm is **provably optimal** and demonstrates how sorting can enable efficient single-pass solutions to seemingly complex problems.
