# Day 5: Cafeteria - Advent of Code 2025

## Part 1: Fresh Ingredient Detection

### Problem

- Kitchen inventory system has **fresh ingredient ID ranges**
- Need to check which **available ingredient IDs** are fresh
- An ingredient is fresh if it falls into **any** range (ranges can overlap)
- Ranges are **inclusive**: `3-5` means IDs 3, 4, and 5 are all fresh

### Example

```
3-5
10-14
16-20
12-18

1
5
8
11
17
32
```

**Fresh ID ranges:**
- `3-5`: covers IDs 3, 4, 5
- `10-14`: covers IDs 10, 11, 12, 13, 14
- `16-20`: covers IDs 16, 17, 18, 19, 20
- `12-18`: covers IDs 12, 13, 14, 15, 16, 17, 18 (overlaps with others)

**Available ingredient IDs check:**
- `1`: ❌ Spoiled (not in any range)
- `5`: ✅ Fresh (in range `3-5`)
- `8`: ❌ Spoiled (not in any range)
- `11`: ✅ Fresh (in range `10-14`)
- `17`: ✅ Fresh (in ranges `16-20` and `12-18`)
- `32`: ❌ Spoiled (not in any range)

**Result:** **3** fresh ingredients

### Solution - Range Membership Check

**Algorithm:** Linear scan with early exit

**Approach:**
1. Parse ranges into list of `(start, end)` tuples
2. Parse ingredient IDs into list
3. For each ingredient ID, check if it falls in any range
4. Use early exit: once found in a range, stop checking
5. Count total fresh ingredients

**Data Structure:** List of tuples for ranges

```python
def solve_part1(data):
    lines = data.strip().split('\n')

    # Find the blank line separating ranges from IDs
    blank_idx = lines.index('')

    # Parse ranges
    ranges = []
    for line in lines[:blank_idx]:
        start, end = map(int, line.split('-'))
        ranges.append((start, end))

    # Parse ingredient IDs
    ingredient_ids = [int(line) for line in lines[blank_idx + 1:]]

    # Count fresh ingredients
    fresh_count = 0
    for ingredient_id in ingredient_ids:
        for start, end in ranges:
            if start <= ingredient_id <= end:
                fresh_count += 1
                break  # Early exit - found in at least one range

    return fresh_count
```

**Complexity:** O(n × m) where n = number of IDs, m = number of ranges

---

## Part 2: Total Fresh IDs in Ranges

### Problem

- Ignore the available ingredient IDs list
- Count **all unique IDs** covered by the fresh ranges
- Ranges can **overlap**, so need to avoid double-counting
- Must merge overlapping/adjacent ranges first

### Example

Same ranges as Part 1:
```
3-5      → IDs: 3, 4, 5
10-14    → IDs: 10, 11, 12, 13, 14
16-20    → IDs: 16, 17, 18, 19, 20
12-18    → IDs: 12, 13, 14, 15, 16, 17, 18
```

**Step 1: Sort ranges**
```
3-5
10-14
12-18    (overlaps with 10-14)
16-20    (overlaps with 12-18)
```

**Step 2: Merge overlapping/adjacent ranges**

- `3-5`: standalone → keep as is
- `10-14` and `12-18`: overlap (14 ≥ 12) → merge to `10-18`
- `10-18` and `16-20`: overlap (18 ≥ 16) → merge to `10-20`

**Merged ranges:**
```
3-5      → 3 IDs (5 - 3 + 1)
10-20    → 11 IDs (20 - 10 + 1)
```

**Total:** 3 + 11 = **14** unique fresh IDs

### Solution - Interval Merging

**Algorithm:** Sort and merge overlapping intervals

**Approach:**
1. Parse ranges into list of `(start, end)` tuples
2. **Sort ranges** by start position
3. **Merge overlapping or adjacent ranges**:
   - If `start <= last_end + 1`: merge by extending last range
   - Otherwise: add new range
4. Count total IDs in merged ranges

**Key insight:** Two ranges are mergeable if `start₂ ≤ end₁ + 1`
- `[3-5]` and `[6-8]` are adjacent (5 + 1 = 6) → merge to `[3-8]`
- `[3-5]` and `[4-8]` overlap → merge to `[3-8]`

```python
def solve_part2(data):
    lines = data.strip().split('\n')

    # Find the blank line separating ranges from IDs
    blank_idx = lines.index('')

    # Parse ranges
    ranges = []
    for line in lines[:blank_idx]:
        start, end = map(int, line.split('-'))
        ranges.append((start, end))

    # Sort ranges by start position
    ranges.sort()

    # Merge overlapping/adjacent ranges
    merged = []
    for start, end in ranges:
        if merged and start <= merged[-1][1] + 1:
            # Overlapping or adjacent - extend last range
            merged[-1] = (merged[-1][0], max(merged[-1][1], end))
        else:
            # Non-overlapping - add new range
            merged.append((start, end))

    # Count total IDs in merged ranges
    total = 0
    for start, end in merged:
        total += end - start + 1

    return total
```

**Complexity:** O(n log n) for sorting + O(n) for merging = **O(n log n)**

---

## Key Insights

### Range Overlap Detection

**Condition for overlap/adjacency:**
```python
start₂ <= end₁ + 1
```

**Examples:**
- `[3-5]` and `[6-8]`: 6 ≤ 5 + 1 → adjacent ✅
- `[3-5]` and `[7-9]`: 7 ≤ 5 + 1 → not adjacent ❌
- `[3-5]` and `[4-8]`: 4 ≤ 5 + 1 → overlapping ✅

### Merging Logic

When merging `[a, b]` and `[c, d]`:
```python
merged_range = (a, max(b, d))
```

**Why `max(b, d)`?** The second range might be contained in the first:
- `[3-10]` and `[5-8]` → merge to `[3-10]` (not `[3-8]`)

### Sorting is Essential

Without sorting, we'd miss merges:
```
Bad order: [10-14], [3-5], [12-18]
→ Can't detect that 10-14 and 12-18 should merge

Good order: [3-5], [10-14], [12-18]
→ Sequential processing catches all merges
```

### Greedy Approach Works

Once ranges are sorted, a **single pass** is sufficient:
- Process left-to-right
- Always merge with the last range in result
- No need to backtrack or re-check

---

## Answers

- **Part 1**: 556 fresh ingredients
- **Part 2**: 10,686,195 total fresh IDs

---

## Code Improvements

### Original vs Optimized

The original code is already quite clean, but here are some potential improvements:

#### Extract Helper Functions

```python
def parse_input(data):
    """Parse ranges and ingredient IDs from input."""
    lines = data.strip().split('\n')
    blank_idx = lines.index('')

    ranges = [tuple(map(int, line.split('-'))) for line in lines[:blank_idx]]
    ingredient_ids = [int(line) for line in lines[blank_idx + 1:]]

    return ranges, ingredient_ids

def is_fresh(ingredient_id, ranges):
    """Check if an ingredient ID is in any range."""
    return any(start <= ingredient_id <= end for start, end in ranges)

def merge_ranges(ranges):
    """Merge overlapping and adjacent ranges."""
    sorted_ranges = sorted(ranges)
    merged = []

    for start, end in sorted_ranges:
        if merged and start <= merged[-1][1] + 1:
            merged[-1] = (merged[-1][0], max(merged[-1][1], end))
        else:
            merged.append((start, end))

    return merged

def count_range_ids(ranges):
    """Count total IDs covered by ranges."""
    return sum(end - start + 1 for start, end in ranges)
```

#### Refactored Solutions

```python
def solve_part1(data):
    ranges, ingredient_ids = parse_input(data)
    return sum(1 for id in ingredient_ids if is_fresh(id, ranges))

def solve_part2(data):
    ranges, _ = parse_input(data)
    merged = merge_ranges(ranges)
    return count_range_ids(merged)
```

**Benefits:**
- ✅ More readable: 2 lines per solution instead of 25
- ✅ Testable: each helper can be tested independently
- ✅ Reusable: `merge_ranges` is a classic algorithm
- ✅ DRY: parsing logic in one place

---

## Related Algorithms & Patterns

### Interval Merging
- **Classic problem**: Merge Intervals (LeetCode #56)
- **Applications**:
  - Calendar scheduling (merge meeting times)
  - IP address range consolidation
  - Memory allocation (merge free blocks)

### Range Query
- **Part 1 approach**: Linear scan (simple but O(n×m))
- **Alternative**: Interval tree for O(log n) queries
  - Only worth it if querying many times
  - For one-time checks, linear is fine

### Sweep Line Algorithm
- Sort events (range starts/ends)
- Process left-to-right
- Track current coverage
- Used in computational geometry

### Set Cover Problem
- Part 2 is essentially: "Which IDs are covered by any range?"
- Related to: union of intervals
- Greedy solution works when intervals are on a line

---

## Complexity Analysis

### Part 1

| Operation | Complexity |
|-----------|-----------|
| Parse input | O(r + i) |
| Check each ID | O(i × r) |
| **Total** | **O(i × r)** |

Where: i = ingredient IDs, r = ranges

**For real input:** ~200 IDs × ~50 ranges = ~10,000 checks (fast)

### Part 2

| Operation | Complexity |
|-----------|-----------|
| Parse input | O(r) |
| Sort ranges | O(r log r) |
| Merge ranges | O(r) |
| Count IDs | O(r) |
| **Total** | **O(r log r)** |

**Optimization:** Sorting is the bottleneck, but r is small (~50 ranges)

---

## Alternative Approaches

### Part 1: Binary Search (Overkill)

If ranges were sorted and non-overlapping, could use binary search for O(log r) per ID.

**Verdict:** Not worth it here (overlapping ranges, small dataset)

### Part 2: Explicit Set Enumeration (Too Slow)

```python
# DON'T DO THIS - very slow for large ranges!
all_ids = set()
for start, end in ranges:
    all_ids.update(range(start, end + 1))
return len(all_ids)
```

**Why bad?** Range `1-10000000` would create 10M elements in memory.

**Lesson:** Work with range endpoints, not individual elements.

---

## Visual Example: Merging Process

```
Input ranges (unsorted):
  3━━━5
       10━━━━━━14
              12━━━━━━━━18
                     16━━━━━━━20

Step 1: Sort by start
  3━━━5
       10━━━━━━14
              12━━━━━━━━18
                     16━━━━━━━20

Step 2: Merge overlaps
  3━━━5
       10━━━━━━━━━━━━━━━━━━20
                    (merged 10-14, 12-18, 16-20)

Final result: 2 ranges
  [3-5]: 3 IDs
  [10-20]: 11 IDs
  Total: 14 IDs
```

---

## Key Takeaways

1. **Part 1**: Simple iteration with early exit is sufficient
2. **Part 2**: Interval merging is a classic greedy algorithm
3. **Sorting unlocks greedy approach**: Process intervals left-to-right
4. **Work with endpoints, not elements**: Avoid materializing huge ranges
5. **One-pass merging**: After sorting, no backtracking needed

This problem teaches fundamental interval/range manipulation - a common pattern in scheduling, resource allocation, and computational geometry problems.
