# Day 3: Lobby - Advent of Code 2025

## Part 1: Maximum 2-Digit Joltage

### Problem

- Each line represents a battery bank with digits 1-9
- Pick exactly 2 batteries (positions) to form a 2-digit number
- Find the maximum possible 2-digit number from each bank
- Sum all maximum values

### Example

```
987654321111111 ‚Üí 98 (positions 0,1)
811111111111119 ‚Üí 89 (positions 0,14)
234234234234278 ‚Üí 78 (positions 13,14)
818181911112111 ‚Üí 92 (positions 5,7)
Total: 357
```

### Solution

Use `itertools.combinations` to generate all pairs of positions, then find the maximum:

```python
from itertools import combinations

def solve_part1(data):
    return sum(
        max(int(bank[i] + bank[j]) for i, j in combinations(range(len(bank)), 2))
        for bank in data.strip().split('\n')
    )
```

**Key insight**: `combinations(range(len(bank)), 2)` generates all pairs `(i,j)` where `i < j`, ensuring we maintain order.

---

## Part 2: Maximum 12-Digit Joltage

### Problem

- Same as Part 1, but now pick exactly 12 batteries
- Form a 12-digit number from the selected positions
- Maximize the resulting number

### Example

```
987654321111111 ‚Üí 987654321111 (skip last 3 ones)
811111111111119 ‚Üí 811111111119 (skip middle ones)
234234234234278 ‚Üí 434234234278 (skip first 2,3,2)
818181911112111 ‚Üí 888911112111 (skip early ones)
Total: 3121910778619
```

### Solution - Greedy Algorithm

To maximize a number with k digits selected from a string:

1. **For each position in the result** (left to right):
   - Find the largest digit in the valid range
   - Valid range: positions that still leave enough characters for remaining digits

2. **Key constraint**: If we need `remaining` more digits after current position, we must leave at least `remaining` characters unselected.

```python
def solve_part2(data, k=12):
    total = 0
    for bank in data.strip().split('\n'):
        n = len(bank)
        result = []
        start = 0

        for pos in range(k):
            remaining_needed = k - pos
            max_end = n - remaining_needed + 1

            # Find position of max digit in valid range
            valid_range = bank[start:max_end]
            best_digit = max(valid_range)
            best_pos = start + valid_range.index(best_digit)

            result.append(best_digit)
            start = best_pos + 1

        total += int(''.join(result))

    return total
```

**Optimisation**: Au lieu d'une boucle manuelle, on utilise `max()` pour trouver le meilleur chiffre et `.index()` pour sa position.

### Why Greedy Works

For string `234234234234278` with k=12:

- Position 0: Need 12 chars. Can check indices 0-3 (must leave 11). Best: '4' at index 3
- Position 1: Need 11 chars. Can check indices 4-4 (must leave 10). Best: '3' at index 4
- Continue: picks 4,3,4,2,3,4,2,3,4,2,7,8

This greedy approach guarantees the lexicographically largest number because:

- We prioritize high digits in leftmost positions
- Each choice maximizes the current digit without preventing future selections

> üç© **Note sur les algorithmes greedy**:
L'algorithme "greedy" (glouton en fran√ßais) s'appelle ainsi parce qu'il fait toujours le choix qui semble le meilleur √† l'instant pr√©sent, sans consid√©rer les cons√©quences futures - un peu comme quelqu'un de gourmand qui prendrait toujours le plus gros morceau de g√¢teau imm√©diatement disponible.

Caract√©ristiques de l'approche "greedy":
Choix localement optimal: √Ä chaque √©tape, l'algorithme prend la d√©cision qui para√Æt la meilleure selon un crit√®re donn√©
Pas de retour en arri√®re: Une fois qu'un choix est fait, il n'est jamais reconsid√©r√©
Myopie: L'algorithme ne regarde pas plus loin que l'√©tape courante

Exemples classiques:
Rendu de monnaie: toujours rendre la pi√®ce de plus grande valeur possible
Probl√®me du sac √† dos fractionnaire: prendre les objets avec le meilleur rapport valeur/poids
Algorithme de Dijkstra: explorer le n≈ìud le plus proche

Important: Les algorithmes greedy ne garantissent pas toujours la solution optimale globale - ils trouvent juste une solution "assez bonne" rapidement. Ils sont souvent utilis√©s dans l'Advent of Code quand on cherche une heuristique efficace
---

## Answers

- **Part 1**: 17244
- **Part 2**: 171435596092638
