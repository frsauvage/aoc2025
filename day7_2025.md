# Day 7: Laboratories - Advent of Code 2025

## Part 1: Tachyon Beam Splitting

### Problem

- A tachyon beam enters at position `S` and moves **downward**
- When a beam hits a splitter `^`, it stops and creates two new beams
- New beams start at positions **immediately left and right** of the splitter
- These new beams continue **downward** from the next row
- Count the total number of beam splits

### Example

```
.......S.......
...............
.......^.......    â† First split: beam hits splitter at row 2
...............
......^.^......    â† Two more splits (left and right beams each hit)
...............
.....^.^.^.....    â† Three more splits
...............
....^.^...^....    â† Three more splits
...............
...^.^...^.^...    â† Four more splits
...............
..^...^.....^..    â† Three more splits
...............
.^.^.^.^.^...^.    â† Five more splits
...............

Total: 21 splits
```

### Solution - BFS with Beam Tracking

Track beams as they propagate downward through the manifold:

```python
from collections import deque

def solve_part1(data):
    lines = data.strip().split('\n')
    grid = [list(line) for line in lines]
    rows, cols = len(grid), len(grid[0])

    # Find starting position S
    start_col = next(c for c in range(cols) if grid[0][c] == 'S')

    # Queue: (start_row, col) - beams moving downward
    queue = deque([(0, start_col)])
    visited_beams = set()
    visited_splits = set()
    split_count = 0

    while queue:
        start_row, col = queue.popleft()

        if (start_row, col) in visited_beams:
            continue
        visited_beams.add((start_row, col))

        # Move beam downward until it hits a splitter or exits
        for row in range(start_row, rows):
            if grid[row][col] == '^':
                # Count split only once per splitter position
                if (row, col) not in visited_splits:
                    visited_splits.add((row, col))
                    split_count += 1

                # Create two new beams from next row
                if col - 1 >= 0:
                    queue.append((row + 1, col - 1))
                if col + 1 < cols:
                    queue.append((row + 1, col + 1))
                break

    return split_count
```

**Key insight**: Track `(start_row, col)` to avoid processing duplicate beams, and track `(row, col)` of splitters to count each split only once.

---

## Part 2: Quantum Tachyon Timeline Counting

### Problem

- A **single quantum particle** enters at `S`
- At each splitter, the particle takes **both paths** (quantum superposition)
- This creates parallel **timelines** (many-worlds interpretation)
- Count the total number of distinct timelines after the particle completes all journeys

### Example Timelines

```
Timeline 1 - Always go left:
.......S.......
.......|.......
......|^.......
......|........
.....|^.^......
Total: 40 distinct timelines
```

Each splitter doubles the number of timelines, but timelines can **merge** when they reach the same position at the same row.

### Solution - Dynamic Programming

Instead of tracking individual paths (exponential), count timelines per position:

```python
def solve_part2(data):
    lines = data.strip().split('\n')
    grid = [list(line) for line in lines]
    rows, cols = len(grid), len(grid[0])

    # Find starting position
    start_col = next(c for c in range(cols) if grid[0][c] == 'S')

    # dp[col] = number of timelines at this column in current row
    current_row_counts = {start_col: 1}

    for row in range(rows):
        next_row_counts = {}

        for col, count in current_row_counts.items():
            if grid[row][col] == '^':
                # Split: each timeline becomes two
                if col - 1 >= 0:
                    next_row_counts[col - 1] = next_row_counts.get(col - 1, 0) + count
                if col + 1 < cols:
                    next_row_counts[col + 1] = next_row_counts.get(col + 1, 0) + count
            else:
                # Continue downward
                next_row_counts[col] = next_row_counts.get(col, 0) + count

        current_row_counts = next_row_counts

    return sum(current_row_counts.values())
```

### Why DP Works

**NaÃ¯ve approach** (exponential):
- Track full path: `(row, col, (split1_choice, split2_choice, ...))`
- Memory: O(2^n) where n = number of splitters
- Time: O(2^n Ã— rows)

**DP approach** (linear):
- Only track: `(row, col) â†’ timeline_count`
- Memory: O(rows Ã— cols)
- Time: O(rows Ã— cols)

**Key insight**: Timelines that reach the same `(row, col)` are **indistinguishable** going forward, so we can merge their counts.

### Timeline Merging Example

```
Row 0: Position 7 has 1 timeline
Row 2: After first split at column 7:
       - Position 6: 1 timeline (went left)
       - Position 8: 1 timeline (went right)

Row 4: After splits at columns 6 and 8:
       - Position 5: 1 timeline
       - Position 7: 2 timelines (merged from 6â†’right and 8â†’left)
       - Position 9: 1 timeline
```

The two timelines reaching position 7 at row 4 took different paths but are **identical** from this point forward, so we count them as 2 timelines at that position.

> ğŸ”¬ **Note sur la programmation dynamique**:
>
> La DP transforme un problÃ¨me exponentiel en problÃ¨me polynomial en identifiant les **sous-problÃ¨mes qui se rÃ©pÃ¨tent**. Ici, au lieu de suivre 2^n chemins distincts, on observe que seule la position actuelle importe pour le futur, pas le chemin pris pour y arriver.
>
> **Principe de la DP**:
> - **Ã‰tat**: Position `(row, col)`
> - **Transition**: Splitter â†’ 2 nouvelles positions, sinon â†’ mÃªme colonne
> - **MÃ©morisation**: Compter combien de chemins mÃ¨nent Ã  chaque Ã©tat
>
> C'est l'Ã©quivalent de compter les chemins dans un graphe orientÃ© acyclique (DAG), un problÃ¨me classique rÃ©solu en O(V + E).

---

## Visualisations

### Vue d'ensemble de la propagation DP

![Timeline Propagation](day7_dp_visualization.png)

**Graphique de gauche** : La grille complÃ¨te avec les compteurs de timelines
- ğŸŸ© Cases vertes = Point de dÃ©part S
- ğŸŸ¥ Cases rouges = Splitters (^)
- ğŸ”µ Cercles bleus = Nombre de timelines Ã  chaque position (taille proportionnelle)

**Graphique de droite** : Ã‰volution du nombre total de timelines
- Croissance de 1 â†’ 40 timelines
- La courbe montre l'effet des splits ET des merges

### Moments clÃ©s de l'Ã©volution

![Timeline Evolution](day7_timeline_evolution.png)

Quatre snapshots illustrant les concepts clÃ©s :

1. **Row 0** : 1 timeline au dÃ©part (colonne 7)
2. **Row 2** : 2 timelines aprÃ¨s le premier split
3. **Row 4** : **Merging en action !**
   - On devrait avoir 4 timelines, mais on n'en a que 3
   - 2 chemins diffÃ©rents arrivent Ã  la mÃªme position (colonne 7)
   - La DP compte simplement "2 timelines ici" au lieu de les suivre sÃ©parÃ©ment
4. **Row 14** : 26 timelines sortent simultanÃ©ment

### Ce que montrent les visualisations

**Le merging (fusion de chemins)** :
- Ã€ la row 4, deux chemins diffÃ©rents convergent vers la mÃªme position
- Sans DP : suivre les 2 chemins sÃ©parÃ©ment â†’ mÃ©moire doublÃ©e
- Avec DP : compter "2 timelines Ã  cette position" â†’ mÃ©moire constante

**L'efficacitÃ© de la DP** :
- Approche naÃ¯ve : stocker 18 billions de chemins complets (input rÃ©el)
- Approche DP : stocker ~21,000 compteurs maximum
- **RÃ©duction de mÃ©moire : facteur de ~10Â¹Â²** ğŸš€

---

## Answers

- **Part 1**: 1537
- **Part 2**: 18818811755665
