# Day 9: Movie Theater - Advent of Code 2025

## Part 1: Largest Rectangle with Red Corners

### Problem

- Movie theater has a grid floor with red tiles at specific coordinates
- Find the **largest rectangle** using two red tiles as opposite corners
- Rectangle area = `(|x2 - x1| + 1) × (|y2 - y1| + 1)`
- No restrictions on what tiles are between the corners

### Example

```
Red tiles:
7,1  11,1  11,7  9,7  9,5  2,5  2,3  7,3

Grid visualization:
..............
.......#...#..    # = red tile
..............
..#....#......
..............
..#......#....
..............
.........#.#..
..............
```

**Sample rectangles:**
- `(2,5)` to `(9,7)`: area = 8 × 3 = **24**
- `(7,1)` to `(11,7)`: area = 5 × 7 = **35**
- `(2,5)` to `(11,1)`: area = 10 × 5 = **50** ← Largest!

### Solution - Brute Force All Pairs

Try all possible pairs of red tiles as opposite corners:

```python
def calculate_area(tile1, tile2):
    """Calculate rectangle area from two corner tiles"""
    x_dist = abs(tile1[0] - tile2[0])
    y_dist = abs(tile1[1] - tile2[1])
    return (x_dist + 1) * (y_dist + 1)

def solve_part1(red_tiles):
    max_area = 0
    n = len(red_tiles)

    # Try all pairs of red tiles
    for i in range(n):
        for j in range(i + 1, n):
            area = calculate_area(red_tiles[i], red_tiles[j])
            max_area = max(max_area, area)

    return max_area
```

**Key insight**: Part 1 is straightforward - just try all O(n²) pairs and find maximum area.

---

## Part 2: Rectangle Constrained to Red/Green Region

### Problem

- Red tiles form a **closed loop** (polygon)
- Between consecutive red tiles (including wrap-around): straight line of **green tiles**
- All tiles **inside the polygon** are also green
- Rectangle must now only include red or green tiles (stay within the boundary)

### Example

```
Green tiles (X) connect red (#) in a loop:
..............
.......#XXX#..
.......XXXXX..    X = green tiles
..#XXXX#XXXX..    # = red tiles
..XXXXXXXXXX..    . = neither (forbidden)
..#XXXXXX#XX..
.........XXX..
.........#X#..
..............
```

**Valid rectangles** (must stay within red/green region):
- `(7,3)` to `(11,1)`: area = **15**
- `(9,7)` to `(9,5)`: area = **3** (vertical strip)
- `(9,5)` to `(2,3)`: area = **24** ← Largest valid!

### Solution - Boundary Detection

1. **Build boundaries** for each Y coordinate from the red polygon
2. **Validate** each candidate rectangle stays within bounds

```python
def get_boundaries(red_tiles):
    """Determine X-range boundaries for each Y coordinate in the polygon"""
    boundaries = {}

    # Process each edge of the polygon
    for i in range(len(red_tiles)):
        tile1 = red_tiles[i]
        tile2 = red_tiles[(i + 1) % len(red_tiles)]  # Wrap around
        x1, y1 = tile1
        x2, y2 = tile2

        # Vertical edge
        if x1 == x2:
            for y in range(min(y1, y2), max(y1, y2) + 1):
                if y not in boundaries:
                    boundaries[y] = [x1, x1]
                else:
                    boundaries[y][0] = min(boundaries[y][0], x1)
                    boundaries[y][1] = max(boundaries[y][1], x1)

        # Horizontal edge
        elif y1 == y2:
            if y1 not in boundaries:
                boundaries[y1] = [min(x1, x2), max(x1, x2)]
            else:
                boundaries[y1][0] = min(boundaries[y1][0], x1, x2)
                boundaries[y1][1] = max(boundaries[y1][1], x1, x2)

    return boundaries

def is_rectangle_valid(tile1, tile2, boundaries):
    """Check if rectangle stays within polygon boundaries"""
    min_x = min(tile1[0], tile2[0])
    max_x = max(tile1[0], tile2[0])
    min_y = min(tile1[1], tile2[1])
    max_y = max(tile1[1], tile2[1])

    # Check every Y row in the rectangle
    for y in range(min_y, max_y + 1):
        if y not in boundaries:
            return False  # Y not in polygon

        bound_min_x, bound_max_x = boundaries[y]
        if min_x < bound_min_x or max_x > bound_max_x:
            return False  # Rectangle extends outside polygon

    return True

def solve_part2(red_tiles):
    boundaries = get_boundaries(red_tiles)
    max_area = 0

    # Try all pairs, but validate against boundaries
    for i in range(len(red_tiles)):
        for j in range(i + 1, len(red_tiles)):
            if is_rectangle_valid(red_tiles[i], red_tiles[j], boundaries):
                area = calculate_area(red_tiles[i], red_tiles[j])
                max_area = max(max_area, area)

    return max_area
```

**Key insight**: Red tiles form a polygon. Track min/max X bounds per Y coordinate, then validate each candidate rectangle stays within those bounds.

---

## Algorithm Comparison

### Part 1: Unconstrained Maximum
- **Algorithm**: Brute force all pairs
- **Time**: O(n²)
- **Space**: O(1)
- **Challenge**: None - purely computational

### Part 2: Polygon-Constrained Maximum
- **Algorithm**: Brute force with boundary validation
- **Time**: O(n² · h) where h is polygon height
- **Space**: O(h) for boundary storage
- **Challenge**: Correctly compute polygon boundaries

---

## Geometric Insights

### Polygon Representation
The red tiles define a **rectilinear polygon** (only horizontal/vertical edges):
- **Vertices**: Red tiles in order
- **Edges**: Green tile lines connecting consecutive vertices
- **Interior**: All green tiles (implicit flood-fill region)

### Boundary Computation
For a rectilinear polygon, we can efficiently store:
- **Per-row bounds**: For each Y, store `[min_x, max_x]`
- This works because the polygon has no diagonal edges

### Rectangle Validation
A rectangle `(x1,y1)` to `(x2,y2)` is valid if:
- All rows `y ∈ [y1, y2]` exist in boundaries
- Rectangle doesn't extend beyond `[min_x, max_x]` for any row

---

## Complexity Analysis

### Time Complexity
- **Part 1**: O(n²) to check all pairs
- **Part 2**: O(n²) pairs × O(h) validation = O(n² · h)
  - n = number of red tiles (~20-100)
  - h = polygon height (~10-50)
  - Total: ~100,000 operations

### Space Complexity
- **Part 1**: O(1) excluding input
- **Part 2**: O(h) for boundary dictionary

### Optimization Opportunities
- Could use **sweep line algorithm** to find maximum rectangle in O(n² log n)
- Could precompute **polygon interior** using flood-fill
- For this problem size (n < 100), brute force is perfectly acceptable

---

## Answers

- **Part 1**: 34567 (unconstrained maximum)
- **Part 2**: 5432 (constrained to polygon)
