# Day 6: Trash Compactor - Advent of Code 2025

## Problem Overview

After jumping into a garbage chute, you find yourself in a trash compactor. While waiting for cephalopods to open the magnetically sealed door, you help with their math homework - solving problems on a worksheet with numbers arranged vertically.

### Problem Details

**Part 1: Vertical Math Worksheet**
- Math problems arranged horizontally in a grid
- Each problem has numbers stacked **vertically** (top-to-bottom)
- Operation (`+` or `*`) at the bottom of each problem
- Problems separated by columns of spaces
- Calculate grand total by summing all problem answers

**Part 2: Right-to-Left Reading**
- Same worksheet, but cephalopod math reads **right-to-left in columns**
- Each **column** is a digit position (rightmost = ones, next = tens, etc.)
- Read **top-to-bottom** within each column to form multi-digit numbers
- Operation still at bottom of problem

### Example

```
123 328  51 64
 45 64  387 23
  6 98  215 314
*   +   *   +
```

**Part 1 Analysis** (reading top-to-bottom):

Reading each problem **top-to-bottom**:

1. **Problem 1** (leftmost):
   - Numbers: 123, 45, 6
   - Operation: `*`
   - Result: 123 × 45 × 6 = **33,210**

2. **Problem 2**:
   - Numbers: 328, 64, 98
   - Operation: `+`
   - Result: 328 + 64 + 98 = **490**

3. **Problem 3**:
   - Numbers: 51, 387, 215
   - Operation: `*`
   - Result: 51 × 387 × 215 = **4,243,455**

4. **Problem 4** (rightmost):
   - Numbers: 64, 23, 314
   - Operation: `+`
   - Result: 64 + 23 + 314 = **401**

**Grand Total**: 33,210 + 490 + 4,243,455 + 401 = **4,277,556**

**Part 2 Analysis** (reading right-to-left in columns):

Reading **right-to-left**, column by column:

**Problem 4** (rightmost columns 12, 13, 14):
```
Col 14: ' ', ' ', '4', ' '  → digit 4
Col 13: '4', '3', '1', ' '  → digit 431
Col 12: '6', '2', '3', '+'  → digit 623, operation +
```
- Numbers: 4, 431, 623 (reading RTL)
- Operation: `+`
- Result: 4 + 431 + 623 = **1,058**

**Problem 3** (columns 8, 9, 10):
```
Col 10: '1', '7', '5', ' '  → digit 175
Col 9:  '5', '8', '1', ' '  → digit 581
Col 8:  ' ', '3', '2', '*'  → digit 32, operation *
```
- Numbers: 175, 581, 32 (reading RTL)
- Operation: `*`
- Result: 175 × 581 × 32 = **3,253,600**

**Problem 2** (columns 4, 5, 6):
- Numbers: 8, 248, 369 (reading RTL)
- Operation: `+`
- Result: 8 + 248 + 369 = **625**

**Problem 1** (leftmost columns 0, 1, 2):
- Numbers: 356, 24, 1 (reading RTL)
- Operation: `*`
- Result: 356 × 24 × 1 = **8,544**

**Grand Total**: 1,058 + 3,253,600 + 625 + 8,544 = **3,263,827**

---

## Solution Approach

### Algorithms

**Part 1 Strategy:** Grid transposition + column parsing
- Transpose rows into columns for easier vertical reading
- Split by all-space columns to identify separate problems
- For each problem group, reconstruct rows to read multi-digit numbers
- Parse operation and numbers, calculate result
- Sum all results

**Part 2 Strategy:** Grid transposition + right-to-left reading
- Transpose rows into columns (same as Part 1)
- Split by all-space columns to identify problems
- **Reverse each problem** to read right-to-left
- Each column = one number (read top-to-bottom for digits)
- Parse operation and calculate

**Complexity:**
- Part 1: O(n × m) where n = rows, m = columns
- Part 2: O(n × m) where n = rows, m = columns

### Algorithm Details

#### Part 1: Vertical Number Reading

```python
def solve_part1(data):
    lines = parse_lines(data)

    # Transpose: convert rows to columns
    max_len = max(len(line) for line in lines)
    columns = []
    for col_idx in range(max_len):
        col = []
        for line in lines:
            if col_idx < len(line):
                col.append(line[col_idx])
            else:
                col.append(' ')
        columns.append(''.join(col))

    # Split into problems (separated by all-space columns)
    problems = []
    current_problem = []

    for col in columns:
        if col.strip() == '':
            if current_problem:
                problems.append(current_problem)
                current_problem = []
        else:
            current_problem.append(col)

    if current_problem:
        problems.append(current_problem)

    # Solve each problem
    total = 0
    for problem in problems:
        # Reconstruct rows to read multi-digit numbers
        problem_rows = []
        max_height = max(len(col) for col in problem)
        for row_idx in range(max_height):
            row = ''
            for col in problem:
                if row_idx < len(col):
                    row += col[row_idx]
                else:
                    row += ' '
            problem_rows.append(row.strip())

        # Parse numbers and operation
        numbers = []
        operation = None

        for row in problem_rows:
            if row in ['+', '*']:
                operation = row
            elif row:  # not empty
                numbers.append(int(row))

        # Apply operation
        if operation == '+':
            result = sum(numbers)
        else:  # '*'
            result = 1
            for num in numbers:
                result *= num

        total += result

    return total
```

#### Part 2: Right-to-Left Column Reading

```python
def solve_part2(data):
    lines = parse_lines(data)

    # Transpose: convert rows to columns (same as Part 1)
    max_len = max(len(line) for line in lines)
    columns = []
    for col_idx in range(max_len):
        col = []
        for line in lines:
            if col_idx < len(line):
                col.append(line[col_idx])
            else:
                col.append(' ')
        columns.append(''.join(col))

    # Split into problems (separated by all-space columns)
    problems = []
    current_problem = []

    for col in columns:
        if col.strip() == '':
            if current_problem:
                problems.append(current_problem)
                current_problem = []
        else:
            current_problem.append(col)

    if current_problem:
        problems.append(current_problem)

    # Solve each problem
    total = 0
    for problem in problems:
        # Reverse problem to read right-to-left
        problem = problem[::-1]

        # Find operation
        operation = None
        for col in problem:
            for char in col:
                if char in ['+', '*']:
                    operation = char
                    break
            if operation:
                break

        if not operation:
            continue

        # Each column = one number (read top-to-bottom)
        numbers = []
        for col in problem:
            num_str = ''
            for char in col:
                if char.isdigit():
                    num_str += char
            if num_str:
                numbers.append(int(num_str))

        # Apply operation
        if operation == '+':
            result = sum(numbers)
        else:  # '*'
            result = 1
            for num in numbers:
                result *= num

        total += result

    return total
```

### Key Algorithmic Decisions

**1. Grid Transposition**

**Why transpose?** Easier to process vertical data as horizontal strings
- Convert `grid[row][col]` → `columns[col][row]`
- Enables vertical reading without nested loops
- Single operation simplifies subsequent parsing

**2. Multi-digit Number Parsing**

- **Part 1:** Concatenate characters horizontally across columns
- **Part 2:** Concatenate characters vertically within each column
- Both use string building: `num_str += char` then `int(num_str)`

**3. Right-to-Left Processing**

- Reverse the problem columns: `problem[::-1]`
- Process from rightmost to leftmost
- Simple array reversal handles the directional reading

**4. Data Structure Choice**

- **List of strings** for column representation
- Simple string operations for digit extraction
- No need for complex 2D arrays after transposition

### Complexity Analysis

**Part 1:**
- Transpose: O(n × m) where n = rows, m = columns
- Split problems: O(m) to scan columns
- Parse problems: O(p × h) where p = problems, h = height
- **Total:** O(n × m)

**Part 2:**
- Same complexity as Part 1: O(n × m)
- Additional reverse operation: O(k) where k = columns per problem (negligible)

**Space complexity:** O(n × m) for storing columns

### Python Dependencies Used

```python
from aocd import get_data, submit  # For AoC integration
from aoc_utils import parse_lines   # Helper to split by newlines
from itertools import groupby       # For simplified version
from functools import reduce        # For simplified version
from operator import mul            # For simplified version
```

**Built-in data structures:**
- `list` - for storing columns and problems
- `str` - for character manipulation
- `int` - for number parsing

---

## Implementation Details

### Dependencies

```python
from aocd import get_data, submit
from aoc_utils import fetch_problem_part1, fetch_problem_part2, parse_lines
```

**Optional optimizations (simplified version):**
```python
from itertools import groupby
from functools import reduce
from operator import mul
```

### Code Structure

```
day6_2025.py
├── solve_part1(data)      # Vertical reading (top-to-bottom)
├── solve_part2(data)      # Right-to-left column reading
└── __main__               # Test cases and submission

day6_2025_simple.py        # Refactored version with itertools
├── transpose(lines)       # Grid transposition helper
├── split_problems(cols)   # Split by spaces using groupby
├── parse_problem(cols)    # Extract numbers and operation
├── calculate(nums, op)    # Apply operation
├── solve_part1(data)      # Simplified (1 line)
└── solve_part2(data)      # Simplified (10 lines)
```

**Simplified version with helper functions:**

```python
from itertools import groupby
from functools import reduce
from operator import mul

def transpose(lines):
    """Cleaner transpose with list comprehension."""
    max_len = max(len(line) for line in lines)
    return [''.join(line[i] if i < len(line) else ' ' for line in lines)
            for i in range(max_len)]

def split_problems(columns):
    """Use groupby to split by spaces."""
    return [list(group) for is_space, group in
            groupby(columns, key=lambda c: c.strip() == '')
            if not is_space]

def calculate(numbers, operation):
    """Functional approach to calculation."""
    return sum(numbers) if operation == '+' else reduce(mul, numbers, 1)

# Simplified solutions
def solve_part1(data):
    columns = transpose(parse_lines(data))
    problems = split_problems(columns)
    return sum(calculate(*parse_problem(p)) for p in problems)

def solve_part2(data):
    columns = transpose(parse_lines(data))
    problems = split_problems(columns)

    total = 0
    for problem in problems:
        problem = problem[::-1]  # Reverse for RTL
        operation = next((char for col in problem for char in col if char in ['+', '*']), None)
        numbers = [int(''.join(c for c in col if c.isdigit()))
                   for col in problem if any(c.isdigit() for c in col)]
        total += calculate(numbers, operation)

    return total
```

---

## Running the Solution

```bash
# Run original version
python day6_2025.py

# Output:
# Example result: 4277556
# Example passed!
# Part 1: 5335495999141
# Part 2 Example result: 3263827
# Part 2 Example passed!
# Part 2: 10142723156431

# Run simplified version
python day6_2025_simple.py

# Output:
# Examples passed!
# Part 1: 5335495999141
# Part 2: 10142723156431
```

**Test cases included:**
- Part 1 example: expects 4,277,556
- Part 2 example: expects 3,263,827

---

## Best Practices Demonstrated

### 1. Grid Transposition Pattern

Transposing the grid is a common technique for:
- Processing vertical data horizontally
- Simplifying iteration logic
- Avoiding nested index calculations

### 2. DRY Principle (Simplified Version)

Extract common operations:
- `transpose()` - reusable grid transformation
- `split_problems()` - generic splitting by delimiter
- `calculate()` - single source of truth for operations

### 3. Functional Programming

Simplified version uses:
- List comprehensions instead of loops
- `itertools.groupby` for elegant splitting
- `functools.reduce` for cleaner multiplication

### 4. Clear Problem Decomposition

Both versions break problem into stages:
1. Transpose grid
2. Split into problems
3. Parse each problem
4. Calculate and sum

---

## Code Optimization Analysis

### Can NumPy Simplify This?

**TL;DR: No. NumPy is 60% SLOWER for this problem.**

#### Benchmark Results (100 runs)

```
NumPy version:   0.7979s
Vanilla Python:  0.4759s
Speedup:         0.60x (slower!)
```

#### Why NumPy Doesn't Help Here

1. **String operations, not numerical computation**
   - NumPy excels at vectorized math operations
   - This problem is text parsing and string manipulation
   - No matrix calculations or numerical transformations

2. **Conversion overhead**
   - Converting strings → char array → transpose → strings adds latency
   - NumPy's optimized C loops don't compensate for conversion cost
   - Small dataset (4 rows) doesn't benefit from vectorization

3. **No vectorization opportunities**
   - Parsing logic requires conditional branching
   - Each problem has different structure (variable columns)
   - Can't batch operations across problems

#### NumPy Code Example (Not Recommended)

```python
import numpy as np

def solve_part1_numpy(data):
    lines = parse_lines(data)

    # Pad and create char array
    max_len = max(len(line) for line in lines)
    lines_padded = [line.ljust(max_len) for line in lines]
    grid = np.array([list(line) for line in lines_padded])

    # Transpose with NumPy
    transposed = grid.T  # ← Only benefit, but minimal

    # Convert back to strings (overhead!)
    columns = [''.join(col) for col in transposed]

    # Rest of the logic is identical...
```

**Verdict:** The `grid.T` transpose is elegant but doesn't justify the overhead.

---

## Performance Comparison

### Code Size Comparison

| Version        | Lines of Code | Readability                    |
|----------------|---------------|--------------------------------|
| Original       | 183 lines     | ⭐⭐⭐ Good                      |
| NumPy          | 195 lines     | ⭐⭐ Harder (conversion overhead) |
| **Simplified** | **87 lines**  | ⭐⭐⭐⭐ Excellent                |

### Performance Comparison

| Version        | Time (100 runs)        | Memory |
|----------------|------------------------|--------|
| Original       | 0.476s                 | Low    |
| NumPy          | 0.798s (60% slower)    | Higher |
| **Simplified** | **0.452s** (5% faster) | Low    |

**Performance hierarchy:**
```
Simplified Python (0.452s) > Original Python (0.476s) > NumPy (0.798s)
     ⭐⭐⭐⭐⭐                    ⭐⭐⭐⭐                    ⭐⭐
```

---

## Key Takeaways

### When to Use NumPy ✅

- Large numerical datasets (thousands+ rows)
- Matrix operations (dot products, eigenvalues, FFT)
- Vectorizable calculations (apply same operation to all elements)
- Image/signal processing

### When NOT to Use NumPy ❌

- String parsing and text manipulation (this problem!)
- Small datasets (< 100 rows)
- Variable-length structures
- Conditional branching logic

### General Rule of Thumb

> "Use NumPy when you're doing **math on numbers**.
> Use vanilla Python when you're doing **logic on strings**."

---

## References

### Related Algorithms

- **Grid Transposition**: Matrix operations, image rotation
- **String Parsing**: Multi-pass parsing, state machines
- **Bidirectional Reading**: RTL languages (Arabic, Hebrew), palindrome detection
- **Functional Programming**: `itertools.groupby`, `functools.reduce`

### Similar Problems

- Text parsing and grid manipulation
- Multi-pass string processing
- Coordinate system transformations

### Further Reading

- [Python itertools documentation](https://docs.python.org/3/library/itertools.html)
- [Functional programming in Python](https://docs.python.org/3/howto/functional.html)
- [Grid/matrix manipulation techniques](https://en.wikipedia.org/wiki/Matrix_transposition)

---

## Answers

- **Part 1**: 5,335,495,999,141 (reading top-to-bottom)
- **Part 2**: 10,142,723,156,431 (reading right-to-left)

---

## Conclusion

This problem demonstrates the importance of **choosing the right tool for the job**:

**Key Insights:**

1. **Grid transposition** simplifies vertical data processing
2. **String operations** are better handled with vanilla Python than NumPy
3. **Functional programming** (itertools, functools) improves code clarity
4. **Performance**: Simple solutions often outperform complex ones

**Optimization Lessons:**

- Don't assume libraries like NumPy always improve performance
- Benchmark before optimizing
- For text parsing, built-in Python tools are sufficient and fast
- Code clarity matters: the simplified version is faster AND more readable

The simplified version wins on **all metrics**: speed, clarity, and brevity, proving that sometimes the best optimization is better code organization, not external libraries.
